var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// front_end/models/trace/EntriesFilter.ts
var EntriesFilter_exports = {};
__export(EntriesFilter_exports, {
  EntriesFilter: () => EntriesFilter,
  FilterApplyAction: () => FilterApplyAction,
  FilterUndoAction: () => FilterUndoAction
});

// front_end/core/platform/array-utilities.ts
var array_utilities_exports = {};
__export(array_utilities_exports, {
  DEFAULT_COMPARATOR: () => DEFAULT_COMPARATOR,
  arrayDoesNotContainNullOrUndefined: () => arrayDoesNotContainNullOrUndefined,
  binaryIndexOf: () => binaryIndexOf,
  intersectOrdered: () => intersectOrdered,
  lowerBound: () => lowerBound,
  mergeOrdered: () => mergeOrdered,
  nearestIndexFromBeginning: () => nearestIndexFromBeginning,
  nearestIndexFromEnd: () => nearestIndexFromEnd,
  removeElement: () => removeElement,
  sortRange: () => sortRange,
  upperBound: () => upperBound
});
var removeElement = (array, element, firstOnly) => {
  let index = array.indexOf(element);
  if (index === -1) {
    return false;
  }
  if (firstOnly) {
    array.splice(index, 1);
    return true;
  }
  for (let i = index + 1, n = array.length; i < n; ++i) {
    if (array[i] !== element) {
      array[index++] = array[i];
    }
  }
  array.length = index;
  return true;
};
function swap(array, i1, i2) {
  const temp = array[i1];
  array[i1] = array[i2];
  array[i2] = temp;
}
function partition(array, comparator, left, right, pivotIndex) {
  const pivotValue = array[pivotIndex];
  swap(array, right, pivotIndex);
  let storeIndex = left;
  for (let i = left; i < right; ++i) {
    if (comparator(array[i], pivotValue) < 0) {
      swap(array, storeIndex, i);
      ++storeIndex;
    }
  }
  swap(array, right, storeIndex);
  return storeIndex;
}
function quickSortRange(array, comparator, left, right, sortWindowLeft, sortWindowRight) {
  if (right <= left) {
    return;
  }
  const pivotIndex = Math.floor(Math.random() * (right - left)) + left;
  const pivotNewIndex = partition(array, comparator, left, right, pivotIndex);
  if (sortWindowLeft < pivotNewIndex) {
    quickSortRange(array, comparator, left, pivotNewIndex - 1, sortWindowLeft, sortWindowRight);
  }
  if (pivotNewIndex < sortWindowRight) {
    quickSortRange(array, comparator, pivotNewIndex + 1, right, sortWindowLeft, sortWindowRight);
  }
}
function sortRange(array, comparator, leftBound, rightBound, sortWindowLeft, sortWindowRight) {
  if (leftBound === 0 && rightBound === array.length - 1 && sortWindowLeft === 0 && sortWindowRight >= rightBound) {
    array.sort(comparator);
  } else {
    quickSortRange(array, comparator, leftBound, rightBound, sortWindowLeft, sortWindowRight);
  }
  return array;
}
var binaryIndexOf = (array, value, comparator) => {
  const index = lowerBound(array, value, comparator);
  return index < array.length && comparator(value, array[index]) === 0 ? index : -1;
};
function mergeOrIntersect(array1, array2, comparator, mergeNotIntersect) {
  const result = [];
  let i = 0;
  let j = 0;
  while (i < array1.length && j < array2.length) {
    const compareValue = comparator(array1[i], array2[j]);
    if (mergeNotIntersect || !compareValue) {
      result.push(compareValue <= 0 ? array1[i] : array2[j]);
    }
    if (compareValue <= 0) {
      i++;
    }
    if (compareValue >= 0) {
      j++;
    }
  }
  if (mergeNotIntersect) {
    while (i < array1.length) {
      result.push(array1[i++]);
    }
    while (j < array2.length) {
      result.push(array2[j++]);
    }
  }
  return result;
}
var intersectOrdered = (array1, array2, comparator) => {
  return mergeOrIntersect(array1, array2, comparator, false);
};
var mergeOrdered = (array1, array2, comparator) => {
  return mergeOrIntersect(array1, array2, comparator, true);
};
var DEFAULT_COMPARATOR = (a, b) => {
  return a < b ? -1 : a > b ? 1 : 0;
};
function lowerBound(array, needle, comparator, left, right) {
  let l = left || 0;
  let r = right !== void 0 ? right : array.length;
  while (l < r) {
    const m = l + r >> 1;
    if (comparator(needle, array[m]) > 0) {
      l = m + 1;
    } else {
      r = m;
    }
  }
  return r;
}
function upperBound(array, needle, comparator, left, right) {
  let l = left || 0;
  let r = right !== void 0 ? right : array.length;
  while (l < r) {
    const m = l + r >> 1;
    if (comparator(needle, array[m]) >= 0) {
      l = m + 1;
    } else {
      r = m;
    }
  }
  return r;
}
function nearestIndex(arr, predicate, searchStart) {
  const searchFromEnd = searchStart === "END" /* END */;
  if (arr.length === 0) {
    return null;
  }
  let left = 0;
  let right = arr.length - 1;
  let pivot = 0;
  let matchesPredicate = false;
  let moveToTheRight = false;
  let middle = 0;
  do {
    middle = left + (right - left) / 2;
    pivot = searchFromEnd ? Math.ceil(middle) : Math.floor(middle);
    matchesPredicate = predicate(arr[pivot]);
    moveToTheRight = matchesPredicate === searchFromEnd;
    if (moveToTheRight) {
      left = Math.min(right, pivot + (left === pivot ? 1 : 0));
    } else {
      right = Math.max(left, pivot + (right === pivot ? -1 : 0));
    }
  } while (right !== left);
  if (!predicate(arr[left])) {
    return null;
  }
  return left;
}
function nearestIndexFromBeginning(arr, predicate) {
  return nearestIndex(arr, predicate, "BEGINNING" /* BEGINNING */);
}
function nearestIndexFromEnd(arr, predicate) {
  return nearestIndex(arr, predicate, "END" /* END */);
}
function arrayDoesNotContainNullOrUndefined(arr) {
  return !arr.includes(null) && !arr.includes(void 0);
}

// front_end/core/platform/map-utilities.ts
var map_utilities_exports = {};
__export(map_utilities_exports, {
  Multimap: () => Multimap,
  getWithDefault: () => getWithDefault,
  inverse: () => inverse
});
var inverse = function(map) {
  const result = new Multimap();
  for (const [key, value] of map.entries()) {
    result.set(value, key);
  }
  return result;
};
var Multimap = class {
  map = /* @__PURE__ */ new Map();
  set(key, value) {
    let set = this.map.get(key);
    if (!set) {
      set = /* @__PURE__ */ new Set();
      this.map.set(key, set);
    }
    set.add(value);
  }
  get(key) {
    return this.map.get(key) || /* @__PURE__ */ new Set();
  }
  has(key) {
    return this.map.has(key);
  }
  hasValue(key, value) {
    const set = this.map.get(key);
    if (!set) {
      return false;
    }
    return set.has(value);
  }
  get size() {
    return this.map.size;
  }
  delete(key, value) {
    const values = this.get(key);
    if (!values) {
      return false;
    }
    const result = values.delete(value);
    if (!values.size) {
      this.map.delete(key);
    }
    return result;
  }
  deleteAll(key) {
    this.map.delete(key);
  }
  keysArray() {
    return [...this.map.keys()];
  }
  valuesArray() {
    const result = [];
    for (const set of this.map.values()) {
      result.push(...set.values());
    }
    return result;
  }
  clear() {
    this.map.clear();
  }
};
function getWithDefault(map, key, defaultValueFactory) {
  let value = map.get(key);
  if (!value) {
    value = defaultValueFactory(key);
    map.set(key, value);
  }
  return value;
}

// front_end/core/platform/number-utilities.ts
var number_utilities_exports = {};
__export(number_utilities_exports, {
  aspectRatio: () => aspectRatio,
  bytesToString: () => bytesToString,
  clamp: () => clamp,
  floor: () => floor,
  greatestCommonDivisor: () => greatestCommonDivisor,
  mod: () => mod,
  toFixedIfFloating: () => toFixedIfFloating,
  withThousandsSeparator: () => withThousandsSeparator
});
var clamp = (num, min, max) => {
  let clampedNumber = num;
  if (num < min) {
    clampedNumber = min;
  } else if (num > max) {
    clampedNumber = max;
  }
  return clampedNumber;
};
var mod = (m, n) => {
  return (m % n + n) % n;
};
var bytesToString = (bytes) => {
  if (bytes < 1e3) {
    return `${bytes.toFixed(0)}\xA0B`;
  }
  const kilobytes = bytes / 1e3;
  if (kilobytes < 100) {
    return `${kilobytes.toFixed(1)}\xA0kB`;
  }
  if (kilobytes < 1e3) {
    return `${kilobytes.toFixed(0)}\xA0kB`;
  }
  const megabytes = kilobytes / 1e3;
  if (megabytes < 100) {
    return `${megabytes.toFixed(1)}\xA0MB`;
  }
  return `${megabytes.toFixed(0)}\xA0MB`;
};
var toFixedIfFloating = (value) => {
  if (!value || Number.isNaN(Number(value))) {
    return value;
  }
  const number = Number(value);
  return number % 1 ? number.toFixed(3) : String(number);
};
var floor = (value, precision = 0) => {
  const mult = Math.pow(10, precision);
  return Math.floor(value * mult) / mult;
};
var greatestCommonDivisor = (a, b) => {
  a = Math.round(a);
  b = Math.round(b);
  while (b !== 0) {
    const t = b;
    b = a % b;
    a = t;
  }
  return a;
};
var commonRatios = /* @__PURE__ */ new Map([
  ["8\u22365", "16\u223610"]
]);
var aspectRatio = (width, height) => {
  const divisor = greatestCommonDivisor(width, height);
  if (divisor !== 0) {
    width /= divisor;
    height /= divisor;
  }
  const result = `${width}\u2236${height}`;
  return commonRatios.get(result) || result;
};
var withThousandsSeparator = function(num) {
  let str = String(num);
  const re = /(\d+)(\d{3})/;
  while (str.match(re)) {
    str = str.replace(re, "$1\xA0$2");
  }
  return str;
};

// front_end/core/platform/typescript-utilities.ts
function assertNever(type, message) {
  throw new Error(message);
}

// front_end/models/trace/helpers/helpers.ts
var helpers_exports = {};
__export(helpers_exports, {
  SamplesIntegrator: () => SamplesIntegrator_exports,
  Timing: () => Timing_exports3,
  Trace: () => Trace_exports,
  TreeHelpers: () => TreeHelpers_exports
});

// front_end/models/trace/helpers/SamplesIntegrator.ts
var SamplesIntegrator_exports = {};
__export(SamplesIntegrator_exports, {
  SamplesIntegrator: () => SamplesIntegrator
});

// front_end/models/trace/types/types.ts
var types_exports = {};
__export(types_exports, {
  Configuration: () => Configuration_exports,
  File: () => File_exports,
  Timing: () => Timing_exports2,
  TraceEvents: () => TraceEvents_exports
});

// front_end/models/trace/types/Configuration.ts
var Configuration_exports = {};
__export(Configuration_exports, {
  DEFAULT: () => DEFAULT,
  configToCacheKey: () => configToCacheKey
});
var DEFAULT = {
  settings: {},
  experiments: {
    timelineV8RuntimeCallStats: false,
    timelineShowAllEvents: false
  },
  processing: {
    eventsPerChunk: 15e3,
    pauseDuration: 1
  }
};
function configToCacheKey(config2) {
  return [
    `experiments.timelineShowAllEvents:${config2.experiments.timelineShowAllEvents}`,
    `experiments.timelineV8RuntimeCallStats:${config2.experiments.timelineV8RuntimeCallStats}`
  ].join("-");
}

// front_end/models/trace/types/File.ts
var File_exports = {};
__export(File_exports, {
  DataOrigin: () => DataOrigin
});
var DataOrigin = /* @__PURE__ */ ((DataOrigin2) => {
  DataOrigin2["CPUProfile"] = "CPUProfile";
  DataOrigin2["TraceEvents"] = "TraceEvents";
  return DataOrigin2;
})(DataOrigin || {});

// front_end/models/trace/types/Timing.ts
var Timing_exports2 = {};
__export(Timing_exports2, {
  MicroSeconds: () => MicroSeconds,
  MilliSeconds: () => MilliSeconds,
  Seconds: () => Seconds,
  TimeUnit: () => TimeUnit
});
function MicroSeconds(value) {
  return value;
}
function MilliSeconds(value) {
  return value;
}
function Seconds(value) {
  return value;
}
var TimeUnit = /* @__PURE__ */ ((TimeUnit2) => {
  TimeUnit2[TimeUnit2["MICROSECONDS"] = 0] = "MICROSECONDS";
  TimeUnit2[TimeUnit2["MILLISECONDS"] = 1] = "MILLISECONDS";
  TimeUnit2[TimeUnit2["SECONDS"] = 2] = "SECONDS";
  TimeUnit2[TimeUnit2["MINUTES"] = 3] = "MINUTES";
  return TimeUnit2;
})(TimeUnit || {});

// front_end/models/trace/types/TraceEvents.ts
var TraceEvents_exports = {};
__export(TraceEvents_exports, {
  AuctionWorkletType: () => AuctionWorkletType,
  CallFrameID: () => CallFrameID,
  KnownEventName: () => KnownEventName,
  LayoutInvalidationReason: () => LayoutInvalidationReason,
  Phase: () => Phase,
  ProcessID: () => ProcessID,
  ProfileID: () => ProfileID,
  StyleRecalcInvalidationReason: () => StyleRecalcInvalidationReason,
  ThreadID: () => ThreadID,
  TraceEventScope: () => TraceEventScope,
  WorkerId: () => WorkerId,
  isAsyncPhase: () => isAsyncPhase,
  isFlowPhase: () => isFlowPhase,
  isLegacyTraceEventDrawFrameBegin: () => isLegacyTraceEventDrawFrameBegin,
  isNestableAsyncPhase: () => isNestableAsyncPhase,
  isProcessName: () => isProcessName,
  isProfileCall: () => isProfileCall,
  isRendererEvent: () => isRendererEvent,
  isSyntheticConsoleTimingTraceEvent: () => isSyntheticConsoleTimingTraceEvent,
  isSyntheticInteractionEvent: () => isSyntheticInteractionEvent,
  isSyntheticLayoutShift: () => isSyntheticLayoutShift,
  isSyntheticNetworkRequestDetailsEvent: () => isSyntheticNetworkRequestDetailsEvent,
  isSyntheticTraceEventCpuProfile: () => isSyntheticTraceEventCpuProfile,
  isSyntheticUserTimingTraceEvent: () => isSyntheticUserTimingTraceEvent,
  isThreadName: () => isThreadName,
  isTraceEventActivateLayerTree: () => isTraceEventActivateLayerTree,
  isTraceEventAnimation: () => isTraceEventAnimation,
  isTraceEventAsyncPhase: () => isTraceEventAsyncPhase,
  isTraceEventAuctionWorkletDoneWithProcess: () => isTraceEventAuctionWorkletDoneWithProcess,
  isTraceEventAuctionWorkletRunningInProcess: () => isTraceEventAuctionWorkletRunningInProcess,
  isTraceEventBegin: () => isTraceEventBegin,
  isTraceEventBeginFrame: () => isTraceEventBeginFrame,
  isTraceEventBeginMainThreadFrame: () => isTraceEventBeginMainThreadFrame,
  isTraceEventCommit: () => isTraceEventCommit,
  isTraceEventCommitLoad: () => isTraceEventCommitLoad,
  isTraceEventComplete: () => isTraceEventComplete,
  isTraceEventCompositeLayers: () => isTraceEventCompositeLayers,
  isTraceEventConsoleTime: () => isTraceEventConsoleTime,
  isTraceEventDispatch: () => isTraceEventDispatch,
  isTraceEventDisplayListItemListSnapshot: () => isTraceEventDisplayListItemListSnapshot,
  isTraceEventDrawFrame: () => isTraceEventDrawFrame,
  isTraceEventDroppedFrame: () => isTraceEventDroppedFrame,
  isTraceEventEnd: () => isTraceEventEnd,
  isTraceEventEventTiming: () => isTraceEventEventTiming,
  isTraceEventEventTimingEnd: () => isTraceEventEventTimingEnd,
  isTraceEventEventTimingStart: () => isTraceEventEventTimingStart,
  isTraceEventFireAnimationFrame: () => isTraceEventFireAnimationFrame,
  isTraceEventFireIdleCallback: () => isTraceEventFireIdleCallback,
  isTraceEventFirstContentfulPaint: () => isTraceEventFirstContentfulPaint,
  isTraceEventFirstPaint: () => isTraceEventFirstPaint,
  isTraceEventFrameCommittedInBrowser: () => isTraceEventFrameCommittedInBrowser,
  isTraceEventGPUTask: () => isTraceEventGPUTask,
  isTraceEventInstant: () => isTraceEventInstant,
  isTraceEventInteractiveTime: () => isTraceEventInteractiveTime,
  isTraceEventInvalidateLayout: () => isTraceEventInvalidateLayout,
  isTraceEventLargestContentfulPaintCandidate: () => isTraceEventLargestContentfulPaintCandidate,
  isTraceEventLargestImagePaintCandidate: () => isTraceEventLargestImagePaintCandidate,
  isTraceEventLargestTextPaintCandidate: () => isTraceEventLargestTextPaintCandidate,
  isTraceEventLayerTreeHostImplSnapshot: () => isTraceEventLayerTreeHostImplSnapshot,
  isTraceEventLayout: () => isTraceEventLayout,
  isTraceEventLayoutInvalidation: () => isTraceEventLayoutInvalidation,
  isTraceEventLayoutShift: () => isTraceEventLayoutShift,
  isTraceEventMainFrameViewport: () => isTraceEventMainFrameViewport,
  isTraceEventMarkDOMContent: () => isTraceEventMarkDOMContent,
  isTraceEventMarkLoad: () => isTraceEventMarkLoad,
  isTraceEventNavigationStart: () => isTraceEventNavigationStart,
  isTraceEventNavigationStartWithURL: () => isTraceEventNavigationStartWithURL,
  isTraceEventNeedsBeginFrameChanged: () => isTraceEventNeedsBeginFrameChanged,
  isTraceEventPaint: () => isTraceEventPaint,
  isTraceEventParseHTML: () => isTraceEventParseHTML,
  isTraceEventPerformanceMark: () => isTraceEventPerformanceMark,
  isTraceEventPerformanceMeasure: () => isTraceEventPerformanceMeasure,
  isTraceEventPrePaint: () => isTraceEventPrePaint,
  isTraceEventProfile: () => isTraceEventProfile,
  isTraceEventProfileChunk: () => isTraceEventProfileChunk,
  isTraceEventRasterTask: () => isTraceEventRasterTask,
  isTraceEventRendererEvent: () => isTraceEventRendererEvent,
  isTraceEventRequestAnimationFrame: () => isTraceEventRequestAnimationFrame,
  isTraceEventRequestIdleCallback: () => isTraceEventRequestIdleCallback,
  isTraceEventRequestMainThreadFrame: () => isTraceEventRequestMainThreadFrame,
  isTraceEventResourceChangePriority: () => isTraceEventResourceChangePriority,
  isTraceEventResourceFinish: () => isTraceEventResourceFinish,
  isTraceEventResourceMarkAsCached: () => isTraceEventResourceMarkAsCached,
  isTraceEventResourceReceiveResponse: () => isTraceEventResourceReceiveResponse,
  isTraceEventResourceReceivedData: () => isTraceEventResourceReceivedData,
  isTraceEventResourceSendRequest: () => isTraceEventResourceSendRequest,
  isTraceEventResourceWillSendRequest: () => isTraceEventResourceWillSendRequest,
  isTraceEventScheduleStyleRecalculation: () => isTraceEventScheduleStyleRecalculation,
  isTraceEventSetLayerId: () => isTraceEventSetLayerId,
  isTraceEventStyleRecalcInvalidation: () => isTraceEventStyleRecalcInvalidation,
  isTraceEventTimeStamp: () => isTraceEventTimeStamp,
  isTraceEventTimerFire: () => isTraceEventTimerFire,
  isTraceEventTimerInstall: () => isTraceEventTimerInstall,
  isTraceEventTracingSessionIdForWorker: () => isTraceEventTracingSessionIdForWorker,
  isTraceEventTracingStartedInBrowser: () => isTraceEventTracingStartedInBrowser,
  isTraceEventUpdateCounters: () => isTraceEventUpdateCounters,
  isTraceEventUpdateLayer: () => isTraceEventUpdateLayer,
  isTraceEventUpdateLayoutTree: () => isTraceEventUpdateLayoutTree,
  isTraceEventWebSocketCreate: () => isTraceEventWebSocketCreate,
  isTraceEventWebSocketDestroy: () => isTraceEventWebSocketDestroy,
  isTraceEventWebSocketReceiveHandshakeResponse: () => isTraceEventWebSocketReceiveHandshakeResponse,
  isTraceEventWebSocketSendHandshakeRequest: () => isTraceEventWebSocketSendHandshakeRequest,
  isWebSocketTraceEvent: () => isWebSocketTraceEvent
});
var Phase = /* @__PURE__ */ ((Phase2) => {
  Phase2["BEGIN"] = "B";
  Phase2["END"] = "E";
  Phase2["COMPLETE"] = "X";
  Phase2["INSTANT"] = "I";
  Phase2["COUNTER"] = "C";
  Phase2["ASYNC_NESTABLE_START"] = "b";
  Phase2["ASYNC_NESTABLE_INSTANT"] = "n";
  Phase2["ASYNC_NESTABLE_END"] = "e";
  Phase2["ASYNC_STEP_INTO"] = "T";
  Phase2["ASYNC_BEGIN"] = "S";
  Phase2["ASYNC_END"] = "F";
  Phase2["ASYNC_STEP_PAST"] = "p";
  Phase2["FLOW_START"] = "s";
  Phase2["FLOW_STEP"] = "t";
  Phase2["FLOW_END"] = "f";
  Phase2["SAMPLE"] = "P";
  Phase2["OBJECT_CREATED"] = "N";
  Phase2["OBJECT_SNAPSHOT"] = "O";
  Phase2["OBJECT_DESTROYED"] = "D";
  Phase2["METADATA"] = "M";
  Phase2["MEMORY_DUMP_GLOBAL"] = "V";
  Phase2["MEMORY_DUMP_PROCESS"] = "v";
  Phase2["MARK"] = "R";
  Phase2["CLOCK_SYNC"] = "c";
  return Phase2;
})(Phase || {});
function isNestableAsyncPhase(phase) {
  return phase === "b" /* ASYNC_NESTABLE_START */ || phase === "e" /* ASYNC_NESTABLE_END */ || phase === "n" /* ASYNC_NESTABLE_INSTANT */;
}
function isAsyncPhase(phase) {
  return isNestableAsyncPhase(phase) || phase === "S" /* ASYNC_BEGIN */ || phase === "T" /* ASYNC_STEP_INTO */ || phase === "F" /* ASYNC_END */ || phase === "p" /* ASYNC_STEP_PAST */;
}
function isFlowPhase(phase) {
  return phase === "s" /* FLOW_START */ || phase === "t" /* FLOW_STEP */ || phase === "f" /* FLOW_END */;
}
var TraceEventScope = /* @__PURE__ */ ((TraceEventScope2) => {
  TraceEventScope2["THREAD"] = "t";
  TraceEventScope2["PROCESS"] = "p";
  TraceEventScope2["GLOBAL"] = "g";
  return TraceEventScope2;
})(TraceEventScope || {});
var AuctionWorkletType = /* @__PURE__ */ ((AuctionWorkletType2) => {
  AuctionWorkletType2["BIDDER"] = "bidder";
  AuctionWorkletType2["SELLER"] = "seller";
  AuctionWorkletType2["UNKNOWN"] = "unknown";
  return AuctionWorkletType2;
})(AuctionWorkletType || {});
function isTraceEventAuctionWorkletRunningInProcess(event) {
  return event.name === "AuctionWorkletRunningInProcess";
}
function isTraceEventAuctionWorkletDoneWithProcess(event) {
  return event.name === "AuctionWorkletDoneWithProcess";
}
function isTraceEventTracingSessionIdForWorker(event) {
  return event.name === "TracingSessionIdForWorker";
}
var LayoutInvalidationReason = /* @__PURE__ */ ((LayoutInvalidationReason2) => {
  LayoutInvalidationReason2["SIZE_CHANGED"] = "Size changed";
  LayoutInvalidationReason2["ATTRIBUTE"] = "Attribute";
  LayoutInvalidationReason2["ADDED_TO_LAYOUT"] = "Added to layout";
  LayoutInvalidationReason2["SCROLLBAR_CHANGED"] = "Scrollbar changed";
  LayoutInvalidationReason2["REMOVED_FROM_LAYOUT"] = "Removed from layout";
  LayoutInvalidationReason2["STYLE_CHANGED"] = "Style changed";
  LayoutInvalidationReason2["FONTS_CHANGED"] = "Fonts changed";
  LayoutInvalidationReason2["UNKNOWN"] = "Unknown";
  return LayoutInvalidationReason2;
})(LayoutInvalidationReason || {});
var StyleRecalcInvalidationReason = /* @__PURE__ */ ((StyleRecalcInvalidationReason2) => {
  StyleRecalcInvalidationReason2["ANIMATION"] = "Animation";
  return StyleRecalcInvalidationReason2;
})(StyleRecalcInvalidationReason || {});
function isTraceEventScheduleStyleRecalculation(event) {
  return event.name === KnownEventName.ScheduleStyleRecalculation;
}
function isSyntheticInteractionEvent(event) {
  return Boolean("interactionId" in event && event.args?.data && "beginEvent" in event.args.data && "endEvent" in event.args.data);
}
function isRendererEvent(event) {
  return isTraceEventRendererEvent(event) || isProfileCall(event);
}
function isTraceEventDrawFrame(event) {
  return event.name === KnownEventName.DrawFrame && event.ph === "I" /* INSTANT */;
}
function isLegacyTraceEventDrawFrameBegin(event) {
  return event.name === KnownEventName.DrawFrame && event.ph === "b" /* ASYNC_NESTABLE_START */;
}
function isTraceEventBeginFrame(event) {
  return Boolean(event.name === KnownEventName.BeginFrame && event.args && "frameSeqId" in event.args);
}
function isTraceEventDroppedFrame(event) {
  return Boolean(event.name === KnownEventName.DroppedFrame && event.args && "frameSeqId" in event.args);
}
function isTraceEventRequestMainThreadFrame(event) {
  return event.name === KnownEventName.RequestMainThreadFrame;
}
function isTraceEventBeginMainThreadFrame(event) {
  return event.name === KnownEventName.BeginMainThreadFrame;
}
function isTraceEventNeedsBeginFrameChanged(event) {
  return event.name === KnownEventName.NeedsBeginFrameChanged;
}
function isTraceEventCommit(event) {
  return Boolean(event.name === KnownEventName.Commit && event.args && "frameSeqId" in event.args);
}
function isTraceEventRasterTask(event) {
  return event.name === KnownEventName.RasterTask;
}
function isTraceEventCompositeLayers(event) {
  return event.name === KnownEventName.CompositeLayers;
}
function isTraceEventActivateLayerTree(event) {
  return event.name === KnownEventName.ActivateLayerTree;
}
function isTraceEventUpdateLayoutTree(event) {
  return event.name === KnownEventName.UpdateLayoutTree;
}
function isTraceEventLayout(event) {
  return event.name === KnownEventName.Layout;
}
function isTraceEventInvalidateLayout(event) {
  return event.name === KnownEventName.InvalidateLayout;
}
var ProfileIdTag = class {
  #profileIdTag;
};
function ProfileID(value) {
  return value;
}
var CallFrameIdTag = class {
  #callFrameIdTag;
};
function CallFrameID(value) {
  return value;
}
var ProcessIdTag = class {
  #processIdTag;
};
function ProcessID(value) {
  return value;
}
var ThreadIdTag = class {
  #threadIdTag;
};
function ThreadID(value) {
  return value;
}
var WorkerIdTag = class {
  #workerIdTag;
};
function WorkerId(value) {
  return value;
}
function isTraceEventComplete(event) {
  return event.ph === "X" /* COMPLETE */;
}
function isTraceEventBegin(event) {
  return event.ph === "B" /* BEGIN */;
}
function isTraceEventEnd(event) {
  return event.ph === "E" /* END */;
}
function isTraceEventDispatch(event) {
  return event.name === "EventDispatch";
}
function isTraceEventInstant(event) {
  return event.ph === "I" /* INSTANT */;
}
function isTraceEventRendererEvent(event) {
  return isTraceEventInstant(event) || isTraceEventComplete(event);
}
function isTraceEventFireIdleCallback(event) {
  return event.name === "FireIdleCallback";
}
function isTraceEventUpdateCounters(event) {
  return event.name === "UpdateCounters";
}
function isThreadName(traceEventData) {
  return traceEventData.name === KnownEventName.ThreadName;
}
function isProcessName(traceEventData) {
  return traceEventData.name === "process_name";
}
function isTraceEventTracingStartedInBrowser(traceEventData) {
  return traceEventData.name === "TracingStartedInBrowser";
}
function isTraceEventFrameCommittedInBrowser(traceEventData) {
  return traceEventData.name === "FrameCommittedInBrowser";
}
function isTraceEventCommitLoad(traceEventData) {
  return traceEventData.name === "CommitLoad";
}
function isTraceEventNavigationStart(traceEventData) {
  return traceEventData.name === "navigationStart";
}
function isTraceEventAnimation(traceEventData) {
  return traceEventData.name === "Animation";
}
function isTraceEventLayoutShift(traceEventData) {
  return traceEventData.name === "LayoutShift";
}
function isTraceEventLayoutInvalidation(traceEventData) {
  return traceEventData.name === "LayoutInvalidationTracking" || traceEventData.name === "ScheduleStyleInvalidationTracking";
}
function isTraceEventStyleRecalcInvalidation(traceEventData) {
  return traceEventData.name === "StyleRecalcInvalidationTracking";
}
function isTraceEventFirstContentfulPaint(traceEventData) {
  return traceEventData.name === "firstContentfulPaint";
}
function isTraceEventLargestContentfulPaintCandidate(traceEventData) {
  return traceEventData.name === "largestContentfulPaint::Candidate";
}
function isTraceEventLargestImagePaintCandidate(traceEventData) {
  return traceEventData.name === "LargestImagePaint::Candidate";
}
function isTraceEventLargestTextPaintCandidate(traceEventData) {
  return traceEventData.name === "LargestTextPaint::Candidate";
}
function isTraceEventMarkLoad(traceEventData) {
  return traceEventData.name === "MarkLoad";
}
function isTraceEventFirstPaint(traceEventData) {
  return traceEventData.name === "firstPaint";
}
function isTraceEventMarkDOMContent(traceEventData) {
  return traceEventData.name === "MarkDOMContent";
}
function isTraceEventInteractiveTime(traceEventData) {
  return traceEventData.name === "InteractiveTime";
}
function isTraceEventEventTiming(traceEventData) {
  return traceEventData.name === KnownEventName.EventTiming;
}
function isTraceEventEventTimingEnd(traceEventData) {
  return isTraceEventEventTiming(traceEventData) && traceEventData.ph === "e" /* ASYNC_NESTABLE_END */;
}
function isTraceEventEventTimingStart(traceEventData) {
  return isTraceEventEventTiming(traceEventData) && traceEventData.ph === "b" /* ASYNC_NESTABLE_START */;
}
function isTraceEventGPUTask(traceEventData) {
  return traceEventData.name === "GPUTask";
}
function isTraceEventProfile(traceEventData) {
  return traceEventData.name === "Profile";
}
function isSyntheticTraceEventCpuProfile(traceEventData) {
  return traceEventData.name === "CpuProfile";
}
function isTraceEventProfileChunk(traceEventData) {
  return traceEventData.name === "ProfileChunk";
}
function isTraceEventResourceChangePriority(traceEventData) {
  return traceEventData.name === "ResourceChangePriority";
}
function isTraceEventResourceSendRequest(traceEventData) {
  return traceEventData.name === "ResourceSendRequest";
}
function isTraceEventResourceReceiveResponse(traceEventData) {
  return traceEventData.name === "ResourceReceiveResponse";
}
function isTraceEventResourceMarkAsCached(traceEventData) {
  return traceEventData.name === "ResourceMarkAsCached";
}
function isTraceEventResourceFinish(traceEventData) {
  return traceEventData.name === "ResourceFinish";
}
function isTraceEventResourceWillSendRequest(traceEventData) {
  return traceEventData.name === "ResourceWillSendRequest";
}
function isTraceEventResourceReceivedData(traceEventData) {
  return traceEventData.name === "ResourceReceivedData";
}
function isSyntheticNetworkRequestDetailsEvent(traceEventData) {
  return traceEventData.name === "SyntheticNetworkRequest";
}
function isTraceEventPrePaint(traceEventData) {
  return traceEventData.name === "PrePaint";
}
function isTraceEventNavigationStartWithURL(event) {
  return Boolean(isTraceEventNavigationStart(event) && event.args.data && event.args.data.documentLoaderURL !== "");
}
function isTraceEventMainFrameViewport(traceEventData) {
  return traceEventData.name === "PaintTimingVisualizer::Viewport";
}
function isSyntheticUserTimingTraceEvent(traceEventData) {
  if (traceEventData.cat !== "blink.user_timing") {
    return false;
  }
  const data21 = traceEventData.args?.data;
  if (!data21) {
    return false;
  }
  return "beginEvent" in data21 && "endEvent" in data21;
}
function isSyntheticConsoleTimingTraceEvent(traceEventData) {
  if (traceEventData.cat !== "blink.console") {
    return false;
  }
  const data21 = traceEventData.args?.data;
  if (!data21) {
    return false;
  }
  return "beginEvent" in data21 && "endEvent" in data21;
}
function isTraceEventPerformanceMeasure(traceEventData) {
  return traceEventData.cat === "blink.user_timing" && isTraceEventAsyncPhase(traceEventData);
}
function isTraceEventPerformanceMark(traceEventData) {
  return traceEventData.cat === "blink.user_timing" && (traceEventData.ph === "R" /* MARK */ || traceEventData.ph === "I" /* INSTANT */);
}
function isTraceEventConsoleTime(traceEventData) {
  return traceEventData.cat === "blink.console" && isTraceEventAsyncPhase(traceEventData);
}
function isTraceEventTimeStamp(traceEventData) {
  return traceEventData.ph === "I" /* INSTANT */ && traceEventData.name === "TimeStamp";
}
function isTraceEventParseHTML(traceEventData) {
  return traceEventData.name === "ParseHTML";
}
function isTraceEventAsyncPhase(traceEventData) {
  const asyncPhases = /* @__PURE__ */ new Set([
    "b" /* ASYNC_NESTABLE_START */,
    "n" /* ASYNC_NESTABLE_INSTANT */,
    "e" /* ASYNC_NESTABLE_END */,
    "T" /* ASYNC_STEP_INTO */,
    "S" /* ASYNC_BEGIN */,
    "F" /* ASYNC_END */,
    "p" /* ASYNC_STEP_PAST */
  ]);
  return asyncPhases.has(traceEventData.ph);
}
function isSyntheticLayoutShift(traceEventData) {
  if (!isTraceEventLayoutShift(traceEventData) || !traceEventData.args.data) {
    return false;
  }
  return "rawEvent" in traceEventData.args.data;
}
function isProfileCall(event) {
  return "callFrame" in event;
}
function isTraceEventPaint(event) {
  return event.name === KnownEventName.Paint;
}
function isTraceEventSetLayerId(event) {
  return event.name === KnownEventName.SetLayerTreeId;
}
function isTraceEventUpdateLayer(event) {
  return event.name === KnownEventName.UpdateLayer;
}
function isTraceEventDisplayListItemListSnapshot(event) {
  return event.name === KnownEventName.DisplayItemListSnapshot;
}
function isTraceEventLayerTreeHostImplSnapshot(event) {
  return event.name === KnownEventName.LayerTreeHostImplSnapshot;
}
function isTraceEventFireAnimationFrame(event) {
  return event.name === KnownEventName.FireAnimationFrame;
}
function isTraceEventRequestAnimationFrame(event) {
  return event.name === KnownEventName.RequestAnimationFrame;
}
function isTraceEventTimerInstall(event) {
  return event.name === KnownEventName.TimerInstall;
}
function isTraceEventTimerFire(event) {
  return event.name === KnownEventName.TimerFire;
}
function isTraceEventRequestIdleCallback(event) {
  return event.name === KnownEventName.RequestIdleCallback;
}
function isTraceEventWebSocketCreate(event) {
  return event.name === KnownEventName.WebSocketCreate;
}
function isTraceEventWebSocketSendHandshakeRequest(event) {
  return event.name === KnownEventName.WebSocketSendHandshakeRequest;
}
function isTraceEventWebSocketReceiveHandshakeResponse(event) {
  return event.name === KnownEventName.WebSocketReceiveHandshakeResponse;
}
function isTraceEventWebSocketDestroy(event) {
  return event.name === KnownEventName.WebSocketDestroy;
}
function isWebSocketTraceEvent(event) {
  return isTraceEventWebSocketCreate(event) || isTraceEventWebSocketDestroy(event) || isTraceEventWebSocketReceiveHandshakeResponse(event) || isTraceEventWebSocketSendHandshakeRequest(event);
}
var KnownEventName = /* @__PURE__ */ ((KnownEventName2) => {
  KnownEventName2["ThreadName"] = "thread_name";
  KnownEventName2["Program"] = "Program";
  KnownEventName2["RunTask"] = "RunTask";
  KnownEventName2["AsyncTask"] = "AsyncTask";
  KnownEventName2["RunMicrotasks"] = "RunMicrotasks";
  KnownEventName2["XHRLoad"] = "XHRLoad";
  KnownEventName2["XHRReadyStateChange"] = "XHRReadyStateChange";
  KnownEventName2["ParseHTML"] = "ParseHTML";
  KnownEventName2["ParseCSS"] = "ParseAuthorStyleSheet";
  KnownEventName2["CompileScript"] = "V8.CompileScript";
  KnownEventName2["CompileCode"] = "V8.CompileCode";
  KnownEventName2["CompileModule"] = "V8.CompileModule";
  KnownEventName2["Optimize"] = "V8.OptimizeCode";
  KnownEventName2["WasmStreamFromResponseCallback"] = "v8.wasm.streamFromResponseCallback";
  KnownEventName2["WasmCompiledModule"] = "v8.wasm.compiledModule";
  KnownEventName2["WasmCachedModule"] = "v8.wasm.cachedModule";
  KnownEventName2["WasmModuleCacheHit"] = "v8.wasm.moduleCacheHit";
  KnownEventName2["WasmModuleCacheInvalid"] = "v8.wasm.moduleCacheInvalid";
  KnownEventName2["ProfileCall"] = "ProfileCall";
  KnownEventName2["EvaluateScript"] = "EvaluateScript";
  KnownEventName2["FunctionCall"] = "FunctionCall";
  KnownEventName2["EventDispatch"] = "EventDispatch";
  KnownEventName2["EvaluateModule"] = "v8.evaluateModule";
  KnownEventName2["RequestMainThreadFrame"] = "RequestMainThreadFrame";
  KnownEventName2["RequestAnimationFrame"] = "RequestAnimationFrame";
  KnownEventName2["CancelAnimationFrame"] = "CancelAnimationFrame";
  KnownEventName2["FireAnimationFrame"] = "FireAnimationFrame";
  KnownEventName2["RequestIdleCallback"] = "RequestIdleCallback";
  KnownEventName2["CancelIdleCallback"] = "CancelIdleCallback";
  KnownEventName2["FireIdleCallback"] = "FireIdleCallback";
  KnownEventName2["TimerInstall"] = "TimerInstall";
  KnownEventName2["TimerRemove"] = "TimerRemove";
  KnownEventName2["TimerFire"] = "TimerFire";
  KnownEventName2["WebSocketCreate"] = "WebSocketCreate";
  KnownEventName2["WebSocketSendHandshake"] = "WebSocketSendHandshakeRequest";
  KnownEventName2["WebSocketReceiveHandshake"] = "WebSocketReceiveHandshakeResponse";
  KnownEventName2["WebSocketDestroy"] = "WebSocketDestroy";
  KnownEventName2["CryptoDoEncrypt"] = "DoEncrypt";
  KnownEventName2["CryptoDoEncryptReply"] = "DoEncryptReply";
  KnownEventName2["CryptoDoDecrypt"] = "DoDecrypt";
  KnownEventName2["CryptoDoDecryptReply"] = "DoDecryptReply";
  KnownEventName2["CryptoDoDigest"] = "DoDigest";
  KnownEventName2["CryptoDoDigestReply"] = "DoDigestReply";
  KnownEventName2["CryptoDoSign"] = "DoSign";
  KnownEventName2["CryptoDoSignReply"] = "DoSignReply";
  KnownEventName2["CryptoDoVerify"] = "DoVerify";
  KnownEventName2["CryptoDoVerifyReply"] = "DoVerifyReply";
  KnownEventName2["V8Execute"] = "V8.Execute";
  KnownEventName2["GC"] = "GCEvent";
  KnownEventName2["DOMGC"] = "BlinkGC.AtomicPhase";
  KnownEventName2["IncrementalGCMarking"] = "V8.GCIncrementalMarking";
  KnownEventName2["MajorGC"] = "MajorGC";
  KnownEventName2["MinorGC"] = "MinorGC";
  KnownEventName2["GCCollectGarbage"] = "BlinkGC.AtomicPhase";
  KnownEventName2["ScheduleStyleRecalculation"] = "ScheduleStyleRecalculation";
  KnownEventName2["RecalculateStyles"] = "RecalculateStyles";
  KnownEventName2["Layout"] = "Layout";
  KnownEventName2["UpdateLayoutTree"] = "UpdateLayoutTree";
  KnownEventName2["InvalidateLayout"] = "InvalidateLayout";
  KnownEventName2["LayoutInvalidationTracking"] = "LayoutInvalidationTracking";
  KnownEventName2["ComputeIntersections"] = "ComputeIntersections";
  KnownEventName2["HitTest"] = "HitTest";
  KnownEventName2["PrePaint"] = "PrePaint";
  KnownEventName2["Layerize"] = "Layerize";
  KnownEventName2["LayoutShift"] = "LayoutShift";
  KnownEventName2["UpdateLayerTree"] = "UpdateLayerTree";
  KnownEventName2["ScheduleStyleInvalidationTracking"] = "ScheduleStyleInvalidationTracking";
  KnownEventName2["StyleRecalcInvalidationTracking"] = "StyleRecalcInvalidationTracking";
  KnownEventName2["StyleInvalidatorInvalidationTracking"] = "StyleInvalidatorInvalidationTracking";
  KnownEventName2["ScrollLayer"] = "ScrollLayer";
  KnownEventName2["UpdateLayer"] = "UpdateLayer";
  KnownEventName2["PaintSetup"] = "PaintSetup";
  KnownEventName2["Paint"] = "Paint";
  KnownEventName2["PaintImage"] = "PaintImage";
  KnownEventName2["Commit"] = "Commit";
  KnownEventName2["CompositeLayers"] = "CompositeLayers";
  KnownEventName2["RasterTask"] = "RasterTask";
  KnownEventName2["ImageDecodeTask"] = "ImageDecodeTask";
  KnownEventName2["ImageUploadTask"] = "ImageUploadTask";
  KnownEventName2["DecodeImage"] = "Decode Image";
  KnownEventName2["ResizeImage"] = "Resize Image";
  KnownEventName2["DrawLazyPixelRef"] = "Draw LazyPixelRef";
  KnownEventName2["DecodeLazyPixelRef"] = "Decode LazyPixelRef";
  KnownEventName2["GPUTask"] = "GPUTask";
  KnownEventName2["Rasterize"] = "Rasterize";
  KnownEventName2["EventTiming"] = "EventTiming";
  KnownEventName2["OptimizeCode"] = "V8.OptimizeCode";
  KnownEventName2["CacheScript"] = "v8.produceCache";
  KnownEventName2["CacheModule"] = "v8.produceModuleCache";
  KnownEventName2["V8Sample"] = "V8Sample";
  KnownEventName2["JitCodeAdded"] = "JitCodeAdded";
  KnownEventName2["JitCodeMoved"] = "JitCodeMoved";
  KnownEventName2["StreamingCompileScript"] = "v8.parseOnBackground";
  KnownEventName2["StreamingCompileScriptWaiting"] = "v8.parseOnBackgroundWaiting";
  KnownEventName2["StreamingCompileScriptParsing"] = "v8.parseOnBackgroundParsing";
  KnownEventName2["BackgroundDeserialize"] = "v8.deserializeOnBackground";
  KnownEventName2["FinalizeDeserialization"] = "V8.FinalizeDeserialization";
  KnownEventName2["CommitLoad"] = "CommitLoad";
  KnownEventName2["MarkLoad"] = "MarkLoad";
  KnownEventName2["MarkDOMContent"] = "MarkDOMContent";
  KnownEventName2["MarkFirstPaint"] = "firstPaint";
  KnownEventName2["MarkFCP"] = "firstContentfulPaint";
  KnownEventName2["MarkLCPCandidate"] = "largestContentfulPaint::Candidate";
  KnownEventName2["MarkLCPInvalidate"] = "largestContentfulPaint::Invalidate";
  KnownEventName2["NavigationStart"] = "navigationStart";
  KnownEventName2["TimeStamp"] = "TimeStamp";
  KnownEventName2["ConsoleTime"] = "ConsoleTime";
  KnownEventName2["UserTiming"] = "UserTiming";
  KnownEventName2["InteractiveTime"] = "InteractiveTime";
  KnownEventName2["BeginFrame"] = "BeginFrame";
  KnownEventName2["NeedsBeginFrameChanged"] = "NeedsBeginFrameChanged";
  KnownEventName2["BeginMainThreadFrame"] = "BeginMainThreadFrame";
  KnownEventName2["ActivateLayerTree"] = "ActivateLayerTree";
  KnownEventName2["DrawFrame"] = "DrawFrame";
  KnownEventName2["DroppedFrame"] = "DroppedFrame";
  KnownEventName2["FrameStartedLoading"] = "FrameStartedLoading";
  KnownEventName2["ResourceWillSendRequest"] = "ResourceWillSendRequest";
  KnownEventName2["ResourceSendRequest"] = "ResourceSendRequest";
  KnownEventName2["ResourceReceiveResponse"] = "ResourceReceiveResponse";
  KnownEventName2["ResourceReceivedData"] = "ResourceReceivedData";
  KnownEventName2["ResourceFinish"] = "ResourceFinish";
  KnownEventName2["ResourceMarkAsCached"] = "ResourceMarkAsCached";
  KnownEventName2["WebSocketSendHandshakeRequest"] = "WebSocketSendHandshakeRequest";
  KnownEventName2["WebSocketReceiveHandshakeResponse"] = "WebSocketReceiveHandshakeResponse";
  KnownEventName2["Profile"] = "Profile";
  KnownEventName2["StartProfiling"] = "CpuProfiler::StartProfiling";
  KnownEventName2["ProfileChunk"] = "ProfileChunk";
  KnownEventName2["UpdateCounters"] = "UpdateCounters";
  KnownEventName2["Animation"] = "Animation";
  KnownEventName2["ParseAuthorStyleSheet"] = "ParseAuthorStyleSheet";
  KnownEventName2["EmbedderCallback"] = "EmbedderCallback";
  KnownEventName2["SetLayerTreeId"] = "SetLayerTreeId";
  KnownEventName2["TracingStartedInPage"] = "TracingStartedInPage";
  KnownEventName2["TracingSessionIdForWorker"] = "TracingSessionIdForWorker";
  KnownEventName2["LazyPixelRef"] = "LazyPixelRef";
  KnownEventName2["LayerTreeHostImplSnapshot"] = "cc::LayerTreeHostImpl";
  KnownEventName2["PictureSnapshot"] = "cc::Picture";
  KnownEventName2["DisplayItemListSnapshot"] = "cc::DisplayItemList";
  KnownEventName2["InputLatencyMouseMove"] = "InputLatency::MouseMove";
  KnownEventName2["InputLatencyMouseWheel"] = "InputLatency::MouseWheel";
  KnownEventName2["ImplSideFling"] = "InputHandlerProxy::HandleGestureFling::started";
  return KnownEventName2;
})(KnownEventName || {});

// front_end/models/trace/helpers/Timing.ts
var Timing_exports3 = {};
__export(Timing_exports3, {
  detectBestTimeUnit: () => detectBestTimeUnit,
  eventTimingsMicroSeconds: () => eventTimingsMicroSeconds,
  eventTimingsMilliSeconds: () => eventTimingsMilliSeconds,
  eventTimingsSeconds: () => eventTimingsSeconds,
  formatMicrosecondsTime: () => formatMicrosecondsTime,
  microSecondsToMilliseconds: () => microSecondsToMilliseconds,
  microSecondsToSeconds: () => microSecondsToSeconds,
  millisecondsToMicroseconds: () => millisecondsToMicroseconds,
  secondsToMicroseconds: () => secondsToMicroseconds,
  secondsToMilliseconds: () => secondsToMilliseconds,
  timeStampForEventAdjustedByClosestNavigation: () => timeStampForEventAdjustedByClosestNavigation,
  traceWindowFromMilliSeconds: () => traceWindowFromMilliSeconds,
  traceWindowMilliSeconds: () => traceWindowMilliSeconds,
  traceWindowMillisecondsToMicroSeconds: () => traceWindowMillisecondsToMicroSeconds
});

// front_end/models/trace/helpers/Trace.ts
var Trace_exports = {};
__export(Trace_exports, {
  activeURLForFrameAtTime: () => activeURLForFrameAtTime,
  addEventToProcessThread: () => addEventToProcessThread,
  createMatchedSortedSyntheticEvents: () => createMatchedSortedSyntheticEvents,
  createSortedSyntheticEvents: () => createSortedSyntheticEvents,
  extractId: () => extractId,
  extractOriginFromTrace: () => extractOriginFromTrace,
  getNavigationForTraceEvent: () => getNavigationForTraceEvent,
  makeProfileCall: () => makeProfileCall,
  matchBeginningAndEndEvents: () => matchBeginningAndEndEvents,
  mergeEventsInOrder: () => mergeEventsInOrder,
  sortTraceEventsInPlace: () => sortTraceEventsInPlace
});
function extractOriginFromTrace(firstNavigationURL) {
  const url = new URL(firstNavigationURL);
  if (url) {
    if (url.host.startsWith("www.")) {
      return url.host.slice(4);
    }
    return url.host;
  }
  return null;
}
function addEventToProcessThread(event, eventsInProcessThread3) {
  const { tid, pid } = event;
  let eventsInThread = eventsInProcessThread3.get(pid);
  if (!eventsInThread) {
    eventsInThread = /* @__PURE__ */ new Map();
  }
  let events2 = eventsInThread.get(tid);
  if (!events2) {
    events2 = [];
  }
  events2.push(event);
  eventsInThread.set(event.tid, events2);
  eventsInProcessThread3.set(event.pid, eventsInThread);
}
function eventTimeComparator(a, b) {
  const aBeginTime = a.ts;
  const bBeginTime = b.ts;
  if (aBeginTime < bBeginTime) {
    return -1;
  }
  if (aBeginTime > bBeginTime) {
    return 1;
  }
  const aDuration = a.dur ?? 0;
  const bDuration = b.dur ?? 0;
  const aEndTime = aBeginTime + aDuration;
  const bEndTime = bBeginTime + bDuration;
  if (aEndTime > bEndTime) {
    return -1;
  }
  if (aEndTime < bEndTime) {
    return 1;
  }
  return 0;
}
function sortTraceEventsInPlace(events2) {
  events2.sort(eventTimeComparator);
}
function mergeEventsInOrder(eventsArray1, eventsArray2) {
  const result = [];
  let i = 0;
  let j = 0;
  while (i < eventsArray1.length && j < eventsArray2.length) {
    const event1 = eventsArray1[i];
    const event2 = eventsArray2[j];
    const compareValue = eventTimeComparator(event1, event2);
    if (compareValue <= 0) {
      result.push(event1);
      i++;
    }
    if (compareValue === 1) {
      result.push(event2);
      j++;
    }
  }
  while (i < eventsArray1.length) {
    result.push(eventsArray1[i++]);
  }
  while (j < eventsArray2.length) {
    result.push(eventsArray2[j++]);
  }
  return result;
}
function getNavigationForTraceEvent(event, eventFrameId, navigationsByFrameId2) {
  const navigations = navigationsByFrameId2.get(eventFrameId);
  if (!navigations || eventFrameId === "") {
    return null;
  }
  const eventNavigationIndex = array_utilities_exports.nearestIndexFromEnd(navigations, (navigation) => navigation.ts <= event.ts);
  if (eventNavigationIndex === null) {
    return null;
  }
  return navigations[eventNavigationIndex];
}
function extractId(event) {
  return event.id ?? event.id2?.global ?? event.id2?.local;
}
function activeURLForFrameAtTime(frameId, time, rendererProcessesByFrame) {
  const processData = rendererProcessesByFrame.get(frameId);
  if (!processData) {
    return null;
  }
  for (const processes2 of processData.values()) {
    for (const processInfo of processes2) {
      if (processInfo.window.min > time || processInfo.window.max < time) {
        continue;
      }
      return processInfo.frame.url;
    }
  }
  return null;
}
function makeProfileCall(node, ts, pid, tid) {
  return {
    cat: "",
    name: "ProfileCall",
    nodeId: node.id,
    args: {},
    ph: TraceEvents_exports.Phase.COMPLETE,
    pid,
    tid,
    ts,
    dur: Timing_exports2.MicroSeconds(0),
    selfTime: Timing_exports2.MicroSeconds(0),
    callFrame: node.callFrame
  };
}
function matchBeginningAndEndEvents(unpairedEvents) {
  const matchedPairs = /* @__PURE__ */ new Map();
  for (const event of unpairedEvents) {
    const id = extractId(event);
    if (id === void 0) {
      continue;
    }
    const syntheticId = `${event.cat}:${id}:${event.name}`;
    const otherEventsWithID = map_utilities_exports.getWithDefault(matchedPairs, syntheticId, () => {
      return { begin: null, end: null };
    });
    const isStartEvent = event.ph === TraceEvents_exports.Phase.ASYNC_NESTABLE_START;
    const isEndEvent = event.ph === TraceEvents_exports.Phase.ASYNC_NESTABLE_END;
    if (isStartEvent) {
      otherEventsWithID.begin = event;
    } else if (isEndEvent) {
      otherEventsWithID.end = event;
    }
  }
  return matchedPairs;
}
function createSortedSyntheticEvents(matchedPairs) {
  const syntheticEvents2 = [];
  for (const [id, eventsPair] of matchedPairs.entries()) {
    if (!eventsPair.begin || !eventsPair.end) {
      continue;
    }
    const event = {
      cat: eventsPair.end.cat,
      ph: eventsPair.end.ph,
      pid: eventsPair.end.pid,
      tid: eventsPair.end.tid,
      id,
      name: eventsPair.begin.name,
      dur: Timing_exports2.MicroSeconds(eventsPair.end.ts - eventsPair.begin.ts),
      ts: eventsPair.begin.ts,
      args: {
        data: {
          beginEvent: eventsPair.begin,
          endEvent: eventsPair.end
        }
      }
    };
    if (event.dur < 0) {
      continue;
    }
    syntheticEvents2.push(event);
  }
  return syntheticEvents2.sort((a, b) => a.ts - b.ts);
}
function createMatchedSortedSyntheticEvents(unpairedAsyncEvents) {
  const matchedPairs = matchBeginningAndEndEvents(unpairedAsyncEvents);
  const syntheticEvents2 = createSortedSyntheticEvents(matchedPairs);
  return syntheticEvents2;
}

// front_end/models/trace/helpers/Timing.ts
var millisecondsToMicroseconds = (value) => Timing_exports2.MicroSeconds(value * 1e3);
var secondsToMilliseconds = (value) => Timing_exports2.MilliSeconds(value * 1e3);
var secondsToMicroseconds = (value) => millisecondsToMicroseconds(secondsToMilliseconds(value));
var microSecondsToMilliseconds = (value) => Timing_exports2.MilliSeconds(value / 1e3);
var microSecondsToSeconds = (value) => Timing_exports2.Seconds(value / 1e3 / 1e3);
function detectBestTimeUnit(timeInMicroseconds) {
  if (timeInMicroseconds < 1e3) {
    return Timing_exports2.TimeUnit.MICROSECONDS;
  }
  const timeInMilliseconds = timeInMicroseconds / 1e3;
  if (timeInMilliseconds < 1e3) {
    return Timing_exports2.TimeUnit.MILLISECONDS;
  }
  const timeInSeconds = timeInMilliseconds / 1e3;
  if (timeInSeconds < 60) {
    return Timing_exports2.TimeUnit.SECONDS;
  }
  return Timing_exports2.TimeUnit.MINUTES;
}
var defaultFormatOptions = {
  style: "unit",
  unit: "millisecond",
  unitDisplay: "narrow"
};
var serialize = (value) => JSON.stringify(value);
var formatterFactory = (key) => {
  return new Intl.NumberFormat(void 0, key ? JSON.parse(key) : {});
};
var formatters = /* @__PURE__ */ new Map();
map_utilities_exports.getWithDefault(formatters, serialize({ style: "decimal" }), formatterFactory);
map_utilities_exports.getWithDefault(formatters, serialize(defaultFormatOptions), formatterFactory);
map_utilities_exports.getWithDefault(formatters, serialize({ ...defaultFormatOptions, unit: "second" }), formatterFactory);
map_utilities_exports.getWithDefault(formatters, serialize({ ...defaultFormatOptions, unit: "minute" }), formatterFactory);
function formatMicrosecondsTime(timeInMicroseconds, opts = {}) {
  if (!opts.format) {
    opts.format = detectBestTimeUnit(timeInMicroseconds);
  }
  const timeInMilliseconds = timeInMicroseconds / 1e3;
  const timeInSeconds = timeInMilliseconds / 1e3;
  const formatterOpts = { ...defaultFormatOptions, ...opts };
  switch (opts.format) {
    case Timing_exports2.TimeUnit.MICROSECONDS: {
      const formatter = map_utilities_exports.getWithDefault(formatters, serialize({ style: "decimal" }), formatterFactory);
      return `${formatter.format(timeInMicroseconds)}\u03BCs`;
    }
    case Timing_exports2.TimeUnit.MILLISECONDS: {
      const formatter = map_utilities_exports.getWithDefault(formatters, serialize(formatterOpts), formatterFactory);
      return formatter.format(timeInMilliseconds);
    }
    case Timing_exports2.TimeUnit.SECONDS: {
      const formatter = map_utilities_exports.getWithDefault(formatters, serialize({ ...formatterOpts, unit: "second" }), formatterFactory);
      return formatter.format(timeInSeconds);
    }
    default: {
      const minuteFormatter = map_utilities_exports.getWithDefault(formatters, serialize({ ...formatterOpts, unit: "minute" }), formatterFactory);
      const secondFormatter = map_utilities_exports.getWithDefault(formatters, serialize({ ...formatterOpts, unit: "second" }), formatterFactory);
      const timeInMinutes = timeInSeconds / 60;
      const [mins, divider, fraction] = minuteFormatter.formatToParts(timeInMinutes);
      let seconds = 0;
      if (divider && fraction) {
        seconds = Math.round(Number(`0.${fraction.value}`) * 60);
      }
      return `${minuteFormatter.format(Number(mins.value))} ${secondFormatter.format(seconds)}`;
    }
  }
}
function timeStampForEventAdjustedByClosestNavigation(event, traceBounds2, navigationsByNavigationId2, navigationsByFrameId2) {
  let eventTimeStamp = event.ts - traceBounds2.min;
  if (event.args?.data?.navigationId) {
    const navigationForEvent = navigationsByNavigationId2.get(event.args.data.navigationId);
    if (navigationForEvent) {
      eventTimeStamp = event.ts - navigationForEvent.ts;
    }
  } else if (event.args?.data?.frame) {
    const navigationForEvent = getNavigationForTraceEvent(event, event.args.data.frame, navigationsByFrameId2);
    if (navigationForEvent) {
      eventTimeStamp = event.ts - navigationForEvent.ts;
    }
  }
  return Timing_exports2.MicroSeconds(eventTimeStamp);
}
function eventTimingsMicroSeconds(event) {
  return {
    startTime: event.ts,
    endTime: Timing_exports2.MicroSeconds(event.ts + (event.dur || Timing_exports2.MicroSeconds(0))),
    duration: Timing_exports2.MicroSeconds(event.dur || 0),
    selfTime: TraceEvents_exports.isRendererEvent(event) ? Timing_exports2.MicroSeconds(event.selfTime || 0) : Timing_exports2.MicroSeconds(event.dur || 0)
  };
}
function eventTimingsMilliSeconds(event) {
  const microTimes = eventTimingsMicroSeconds(event);
  return {
    startTime: microSecondsToMilliseconds(microTimes.startTime),
    endTime: microSecondsToMilliseconds(microTimes.endTime),
    duration: microSecondsToMilliseconds(microTimes.duration),
    selfTime: microSecondsToMilliseconds(microTimes.selfTime)
  };
}
function eventTimingsSeconds(event) {
  const microTimes = eventTimingsMicroSeconds(event);
  return {
    startTime: microSecondsToSeconds(microTimes.startTime),
    endTime: microSecondsToSeconds(microTimes.endTime),
    duration: microSecondsToSeconds(microTimes.duration),
    selfTime: microSecondsToSeconds(microTimes.selfTime)
  };
}
function traceWindowMilliSeconds(bounds) {
  return {
    min: microSecondsToMilliseconds(bounds.min),
    max: microSecondsToMilliseconds(bounds.max),
    range: microSecondsToMilliseconds(bounds.range)
  };
}
function traceWindowMillisecondsToMicroSeconds(bounds) {
  return {
    min: millisecondsToMicroseconds(bounds.min),
    max: millisecondsToMicroseconds(bounds.max),
    range: millisecondsToMicroseconds(bounds.range)
  };
}
function traceWindowFromMilliSeconds(min, max) {
  const traceWindow = {
    min: millisecondsToMicroseconds(min),
    max: millisecondsToMicroseconds(max),
    range: millisecondsToMicroseconds(Timing_exports2.MilliSeconds(max - min))
  };
  return traceWindow;
}

// front_end/models/trace/helpers/SamplesIntegrator.ts
var SamplesIntegrator = class {
  #constructedProfileCalls = [];
  #currentJSStack = [];
  #processId;
  #threadId;
  #lockedJsStackDepth = [];
  #fakeJSInvocation = false;
  #profileModel;
  #nodeForGC = /* @__PURE__ */ new Map();
  #engineConfig;
  constructor(profileModel, pid, tid, configuration) {
    this.#profileModel = profileModel;
    this.#threadId = tid;
    this.#processId = pid;
    this.#engineConfig = configuration || Configuration_exports.DEFAULT;
  }
  buildProfileCalls(traceEvents) {
    const mergedEvents = mergeEventsInOrder(traceEvents, this.callsFromProfileSamples());
    const stack = [];
    for (let i = 0; i < mergedEvents.length; i++) {
      const event = mergedEvents[i];
      if (event.ph === TraceEvents_exports.Phase.INSTANT) {
        continue;
      }
      if (stack.length === 0) {
        if (TraceEvents_exports.isProfileCall(event)) {
          this.#onProfileCall(event);
          continue;
        }
        stack.push(event);
        this.#onTraceEventStart(event);
        continue;
      }
      const parentEvent = stack.at(-1);
      if (parentEvent === void 0) {
        continue;
      }
      const begin = event.ts;
      const parentBegin = parentEvent.ts;
      const parentDuration = parentEvent.dur || 0;
      const parentEnd = parentBegin + parentDuration;
      const startsAfterParent = begin >= parentEnd;
      if (startsAfterParent) {
        this.#onTraceEventEnd(parentEvent);
        stack.pop();
        i--;
        continue;
      }
      if (TraceEvents_exports.isProfileCall(event)) {
        this.#onProfileCall(event, parentEvent);
        continue;
      }
      this.#onTraceEventStart(event);
      stack.push(event);
    }
    while (stack.length) {
      const last = stack.pop();
      if (last) {
        this.#onTraceEventEnd(last);
      }
    }
    return this.#constructedProfileCalls;
  }
  #onTraceEventStart(event) {
    if (event.name === TraceEvents_exports.KnownEventName.RunMicrotasks || event.name === TraceEvents_exports.KnownEventName.RunTask) {
      this.#lockedJsStackDepth = [];
      this.#truncateJSStack(0, event.ts);
      this.#fakeJSInvocation = false;
    }
    if (this.#fakeJSInvocation) {
      this.#truncateJSStack(this.#lockedJsStackDepth.pop() || 0, event.ts);
      this.#fakeJSInvocation = false;
    }
    this.#extractStackTrace(event);
    this.#lockedJsStackDepth.push(this.#currentJSStack.length);
  }
  #onProfileCall(event, parent) {
    if (parent && SamplesIntegrator.isJSInvocationEvent(parent) || this.#fakeJSInvocation) {
      this.#extractStackTrace(event);
    } else if (TraceEvents_exports.isProfileCall(event) && this.#currentJSStack.length === 0) {
      this.#fakeJSInvocation = true;
      const stackDepthBefore = this.#currentJSStack.length;
      this.#extractStackTrace(event);
      this.#lockedJsStackDepth.push(stackDepthBefore);
    }
  }
  #onTraceEventEnd(event) {
    const endTime = Timing_exports2.MicroSeconds(event.ts + (event.dur || 0));
    this.#truncateJSStack(this.#lockedJsStackDepth.pop() || 0, endTime);
  }
  callsFromProfileSamples() {
    const samples = this.#profileModel.samples;
    const timestamps = this.#profileModel.timestamps;
    if (!samples) {
      return [];
    }
    const calls = [];
    let prevNode;
    for (let i = 0; i < samples.length; i++) {
      const node = this.#profileModel.nodeByIndex(i);
      const timestamp = millisecondsToMicroseconds(Timing_exports2.MilliSeconds(timestamps[i]));
      if (!node) {
        continue;
      }
      const call = makeProfileCall(node, timestamp, this.#processId, this.#threadId);
      calls.push(call);
      if (node.id === this.#profileModel.gcNode?.id && prevNode) {
        this.#nodeForGC.set(call, prevNode);
        continue;
      }
      prevNode = node;
    }
    return calls;
  }
  #getStackTraceFromProfileCall(profileCall) {
    let node = this.#profileModel.nodeById(profileCall.nodeId);
    const isGarbageCollection = node?.id === this.#profileModel.gcNode?.id;
    if (isGarbageCollection) {
      node = this.#nodeForGC.get(profileCall) || null;
    }
    if (!node) {
      return [];
    }
    const callFrames = new Array(node.depth + 1 + Number(isGarbageCollection));
    let i = callFrames.length - 1;
    if (isGarbageCollection) {
      callFrames[i--] = profileCall;
    }
    while (node) {
      callFrames[i--] = makeProfileCall(node, profileCall.ts, this.#processId, this.#threadId);
      node = node.parent;
    }
    return callFrames;
  }
  #extractStackTrace(event) {
    const stackTrace = TraceEvents_exports.isProfileCall(event) ? this.#getStackTraceFromProfileCall(event) : this.#currentJSStack;
    SamplesIntegrator.filterStackFrames(stackTrace, this.#engineConfig);
    const endTime = event.ts + (event.dur || 0);
    const minFrames = Math.min(stackTrace.length, this.#currentJSStack.length);
    let i;
    for (i = this.#lockedJsStackDepth.at(-1) || 0; i < minFrames; ++i) {
      const newFrame = stackTrace[i].callFrame;
      const oldFrame = this.#currentJSStack[i].callFrame;
      if (!SamplesIntegrator.framesAreEqual(newFrame, oldFrame)) {
        break;
      }
      this.#currentJSStack[i].dur = Timing_exports2.MicroSeconds(Math.max(this.#currentJSStack[i].dur || 0, endTime - this.#currentJSStack[i].ts));
    }
    this.#truncateJSStack(i, event.ts);
    for (; i < stackTrace.length; ++i) {
      const call = stackTrace[i];
      if (call.nodeId === this.#profileModel.programNode?.id || call.nodeId === this.#profileModel.root?.id || call.nodeId === this.#profileModel.idleNode?.id || call.nodeId === this.#profileModel.gcNode?.id) {
        continue;
      }
      this.#currentJSStack.push(call);
      this.#constructedProfileCalls.push(call);
    }
  }
  #truncateJSStack(depth, time) {
    if (this.#lockedJsStackDepth.length) {
      const lockedDepth = this.#lockedJsStackDepth.at(-1);
      if (lockedDepth && depth < lockedDepth) {
        console.error(`Child stack is shallower (${depth}) than the parent stack (${lockedDepth}) at ${time}`);
        depth = lockedDepth;
      }
    }
    if (this.#currentJSStack.length < depth) {
      console.error(`Trying to truncate higher than the current stack size at ${time}`);
      depth = this.#currentJSStack.length;
    }
    for (let k = 0; k < this.#currentJSStack.length; ++k) {
      this.#currentJSStack[k].dur = Timing_exports2.MicroSeconds(Math.max(time - this.#currentJSStack[k].ts, 0));
    }
    this.#currentJSStack.length = depth;
  }
  static isJSInvocationEvent(event) {
    switch (event.name) {
      case TraceEvents_exports.KnownEventName.RunMicrotasks:
      case TraceEvents_exports.KnownEventName.FunctionCall:
      case TraceEvents_exports.KnownEventName.EvaluateScript:
      case TraceEvents_exports.KnownEventName.EvaluateModule:
      case TraceEvents_exports.KnownEventName.EventDispatch:
      case TraceEvents_exports.KnownEventName.V8Execute:
        return true;
    }
    if (event.name.startsWith("v8") || event.name.startsWith("V8")) {
      return true;
    }
    return false;
  }
  static framesAreEqual(frame1, frame2) {
    return frame1.scriptId === frame2.scriptId && frame1.functionName === frame2.functionName && frame1.lineNumber === frame2.lineNumber;
  }
  static showNativeName(name, runtimeCallStatsEnabled) {
    return runtimeCallStatsEnabled && Boolean(SamplesIntegrator.nativeGroup(name));
  }
  static nativeGroup(nativeName) {
    if (nativeName.startsWith("Parse")) {
      return "Parse";
    }
    if (nativeName.startsWith("Compile") || nativeName.startsWith("Recompile")) {
      return "Compile";
    }
    return null;
  }
  static isNativeRuntimeFrame(frame) {
    return frame.url === "native V8Runtime";
  }
  static filterStackFrames(stack, engineConfig) {
    const showAllEvents = engineConfig.experiments.timelineShowAllEvents;
    if (showAllEvents) {
      return;
    }
    let previousNativeFrameName = null;
    let j = 0;
    for (let i = 0; i < stack.length; ++i) {
      const frame = stack[i].callFrame;
      const nativeRuntimeFrame = SamplesIntegrator.isNativeRuntimeFrame(frame);
      if (nativeRuntimeFrame && !SamplesIntegrator.showNativeName(frame.functionName, engineConfig.experiments.timelineV8RuntimeCallStats)) {
        continue;
      }
      const nativeFrameName = nativeRuntimeFrame ? SamplesIntegrator.nativeGroup(frame.functionName) : null;
      if (previousNativeFrameName && previousNativeFrameName === nativeFrameName) {
        continue;
      }
      previousNativeFrameName = nativeFrameName;
      stack[j++] = stack[i];
    }
    stack.length = j;
  }
};

// front_end/models/trace/helpers/TreeHelpers.ts
var TreeHelpers_exports = {};
__export(TreeHelpers_exports, {
  makeEmptyTraceEntryNode: () => makeEmptyTraceEntryNode,
  makeEmptyTraceEntryTree: () => makeEmptyTraceEntryTree,
  makeTraceEntryNodeId: () => makeTraceEntryNodeId,
  treify: () => treify,
  walkEntireTree: () => walkEntireTree,
  walkTreeFromEntry: () => walkTreeFromEntry
});
var nodeIdCount = 0;
var makeTraceEntryNodeId = () => ++nodeIdCount;
var makeEmptyTraceEntryTree = () => ({
  roots: /* @__PURE__ */ new Set(),
  maxDepth: 0
});
var makeEmptyTraceEntryNode = (entry, id) => ({
  entry,
  id,
  parent: null,
  children: [],
  depth: 0
});
var TraceEntryNodeIdTag = class {
  #tag;
};
function treify(entries, options) {
  const entryToNode3 = /* @__PURE__ */ new Map();
  const stack = [];
  nodeIdCount = -1;
  const tree = makeEmptyTraceEntryTree();
  for (let i = 0; i < entries.length; i++) {
    const event = entries[i];
    if (options && !options.filter.has(event.name)) {
      continue;
    }
    const duration = event.dur || 0;
    const nodeId = makeTraceEntryNodeId();
    const node = makeEmptyTraceEntryNode(event, nodeId);
    if (stack.length === 0) {
      tree.roots.add(node);
      event.selfTime = Timing_exports2.MicroSeconds(duration);
      stack.push(node);
      tree.maxDepth = Math.max(tree.maxDepth, stack.length);
      entryToNode3.set(event, node);
      continue;
    }
    const parentNode = stack.at(-1);
    if (parentNode === void 0) {
      throw new Error("Impossible: no parent node found in the stack");
    }
    const parentEvent = parentNode.entry;
    const begin = event.ts;
    const parentBegin = parentEvent.ts;
    const parentDuration = parentEvent.dur || 0;
    const end = begin + duration;
    const parentEnd = parentBegin + parentDuration;
    const startsBeforeParent = begin < parentBegin;
    if (startsBeforeParent) {
      throw new Error("Impossible: current event starts before the parent event");
    }
    const startsAfterParent = begin >= parentEnd;
    if (startsAfterParent) {
      stack.pop();
      i--;
      nodeIdCount--;
      continue;
    }
    const endsAfterParent = end > parentEnd;
    if (endsAfterParent) {
      continue;
    }
    node.depth = stack.length;
    node.parent = parentNode;
    parentNode.children.push(node);
    event.selfTime = Timing_exports2.MicroSeconds(duration);
    if (parentEvent.selfTime !== void 0) {
      parentEvent.selfTime = Timing_exports2.MicroSeconds(parentEvent.selfTime - (event.dur || 0));
    }
    stack.push(node);
    tree.maxDepth = Math.max(tree.maxDepth, stack.length);
    entryToNode3.set(event, node);
  }
  return { tree, entryToNode: entryToNode3 };
}
function walkTreeFromEntry(entryToNode3, rootEntry, onEntryStart, onEntryEnd) {
  const startNode = entryToNode3.get(rootEntry);
  if (!startNode) {
    return;
  }
  walkTreeByNode(entryToNode3, startNode, onEntryStart, onEntryEnd);
}
function walkEntireTree(entryToNode3, tree, onEntryStart, onEntryEnd, traceWindowToInclude, minDuration) {
  for (const rootNode of tree.roots) {
    walkTreeByNode(entryToNode3, rootNode, onEntryStart, onEntryEnd, traceWindowToInclude, minDuration);
  }
}
function walkTreeByNode(entryToNode3, rootNode, onEntryStart, onEntryEnd, traceWindowToInclude, minDuration) {
  if (traceWindowToInclude && !treeNodeIsInWindow(rootNode, traceWindowToInclude)) {
    return;
  }
  if (typeof minDuration !== "undefined") {
    const duration = Timing_exports2.MicroSeconds(rootNode.entry.ts + Timing_exports2.MicroSeconds(rootNode.entry.dur || 0));
    if (duration < minDuration) {
      return;
    }
  }
  onEntryStart(rootNode.entry);
  for (const child of rootNode.children) {
    walkTreeByNode(entryToNode3, child, onEntryStart, onEntryEnd, traceWindowToInclude, minDuration);
  }
  onEntryEnd(rootNode.entry);
}
function treeNodeIsInWindow(node, traceWindow) {
  const startTime = node.entry.ts;
  const endTime = node.entry.ts + (node.entry.dur || 0);
  if (startTime >= traceWindow.min && startTime < traceWindow.max) {
    return true;
  }
  if (endTime > traceWindow.min && endTime <= traceWindow.max) {
    return true;
  }
  if (startTime <= traceWindow.min && endTime >= traceWindow.max) {
    return true;
  }
  return false;
}

// front_end/models/trace/EntriesFilter.ts
var FilterApplyAction = /* @__PURE__ */ ((FilterApplyAction2) => {
  FilterApplyAction2["MERGE_FUNCTION"] = "MERGE_FUNCTION";
  FilterApplyAction2["COLLAPSE_FUNCTION"] = "COLLAPSE_FUNCTION";
  FilterApplyAction2["COLLAPSE_REPEATING_DESCENDANTS"] = "COLLAPSE_REPEATING_DESCENDANTS";
  return FilterApplyAction2;
})(FilterApplyAction || {});
var FilterUndoAction = /* @__PURE__ */ ((FilterUndoAction2) => {
  FilterUndoAction2["UNDO_ALL_ACTIONS"] = "UNDO_ALL_ACTIONS";
  FilterUndoAction2["UNDO_COLLAPSE_FUNCTION"] = "UNDO_COLLAPSE_FUNCTION";
  FilterUndoAction2["UNDO_COLLAPSE_REPEATING_DESCENDANTS"] = "UNDO_COLLAPSE_REPEATING_DESCENDANTS";
  return FilterUndoAction2;
})(FilterUndoAction || {});
var filterApplyActionSet = /* @__PURE__ */ new Set([
  "MERGE_FUNCTION" /* MERGE_FUNCTION */,
  "COLLAPSE_FUNCTION" /* COLLAPSE_FUNCTION */,
  "COLLAPSE_REPEATING_DESCENDANTS" /* COLLAPSE_REPEATING_DESCENDANTS */
]);
var filterUndoActionSet = /* @__PURE__ */ new Set([
  "UNDO_ALL_ACTIONS" /* UNDO_ALL_ACTIONS */,
  "UNDO_COLLAPSE_FUNCTION" /* UNDO_COLLAPSE_FUNCTION */,
  "UNDO_COLLAPSE_REPEATING_DESCENDANTS" /* UNDO_COLLAPSE_REPEATING_DESCENDANTS */
]);
var actionToUndoActionMap = /* @__PURE__ */ new Map([
  ["UNDO_COLLAPSE_FUNCTION" /* UNDO_COLLAPSE_FUNCTION */, "COLLAPSE_FUNCTION" /* COLLAPSE_FUNCTION */],
  ["UNDO_COLLAPSE_REPEATING_DESCENDANTS" /* UNDO_COLLAPSE_REPEATING_DESCENDANTS */, "COLLAPSE_REPEATING_DESCENDANTS" /* COLLAPSE_REPEATING_DESCENDANTS */]
]);
var EntriesFilter = class {
  #entryToNode;
  #lastInvisibleEntries = null;
  #activeActions = [];
  #modifiedVisibleEntries = [];
  constructor(entryToNode3) {
    this.#entryToNode = entryToNode3;
  }
  applyAction(action) {
    if (this.isUserApplyFilterAction(action)) {
      this.#modifiedVisibleEntries.push(action.entry);
      if (this.#actionIsActive(action)) {
        return;
      }
      this.#activeActions.push(action);
    } else if (this.isFilterUndoAction(action.type)) {
      const entryIndex = this.#modifiedVisibleEntries.indexOf(action.entry);
      this.#modifiedVisibleEntries.splice(entryIndex);
      this.#applyUndoAction(action.type, action.entry);
    }
    this.#lastInvisibleEntries = null;
  }
  #applyUndoAction(action, entry) {
    switch (action) {
      case "UNDO_ALL_ACTIONS" /* UNDO_ALL_ACTIONS */: {
        this.#activeActions = [];
        this.#modifiedVisibleEntries = [];
        break;
      }
      default: {
        const actionToRemove = actionToUndoActionMap.get(action);
        if (actionToRemove) {
          this.removeActiveAction({
            type: actionToRemove,
            entry
          });
        }
        break;
      }
    }
  }
  removeActiveAction(action) {
    this.#activeActions = this.#activeActions.filter((activeAction) => {
      if (activeAction.type === action.type && activeAction.entry === action.entry) {
        return false;
      }
      return true;
    });
  }
  #actionIsActive(action) {
    return this.#activeActions.some((activeAction) => {
      return action.entry === activeAction.entry && action.type === activeAction.type;
    });
  }
  invisibleEntries() {
    if (this.#activeActions.length === 0) {
      return [];
    }
    return this.#calculateInvisibleEntries();
  }
  #calculateInvisibleEntries() {
    if (this.#lastInvisibleEntries) {
      return this.#lastInvisibleEntries;
    }
    const entriesToHide = /* @__PURE__ */ new Set();
    for (const action of this.#activeActions) {
      switch (action.type) {
        case "MERGE_FUNCTION" /* MERGE_FUNCTION */: {
          entriesToHide.add(action.entry);
          break;
        }
        case "COLLAPSE_FUNCTION" /* COLLAPSE_FUNCTION */: {
          const entryNode = this.#entryToNode.get(action.entry);
          if (!entryNode) {
            continue;
          }
          const allAncestors = this.#findAllAncestorsOfNode(entryNode);
          allAncestors.forEach((ancestor) => entriesToHide.add(ancestor));
          break;
        }
        case "COLLAPSE_REPEATING_DESCENDANTS" /* COLLAPSE_REPEATING_DESCENDANTS */: {
          const entryNode = this.#entryToNode.get(action.entry);
          if (!entryNode) {
            continue;
          }
          const allRepeatingDescendants = this.#findAllRepeatingDescendantsOfNext(entryNode);
          allRepeatingDescendants.forEach((ancestor) => entriesToHide.add(ancestor));
          break;
        }
        default:
          assertNever(action.type, `Unknown EntriesFilter action: ${action.type}`);
      }
    }
    this.#lastInvisibleEntries = [...entriesToHide];
    return this.#lastInvisibleEntries;
  }
  #findAllAncestorsOfNode(root) {
    const ancestors = [];
    const children = [...root.children];
    while (children.length > 0) {
      const childNode = children.shift();
      if (childNode) {
        ancestors.push(childNode.entry);
        children.push(...childNode.children);
      }
    }
    return ancestors;
  }
  #findAllRepeatingDescendantsOfNext(root) {
    const children = [...root.children];
    const repeatingNodes = [];
    const rootIsProfileCall = TraceEvents_exports.isProfileCall(root.entry);
    while (children.length > 0) {
      const childNode = children.shift();
      if (childNode) {
        const childIsProfileCall = TraceEvents_exports.isProfileCall(childNode.entry);
        if (rootIsProfileCall && childIsProfileCall) {
          const rootNodeEntry = root.entry;
          const childNodeEntry = childNode.entry;
          if (SamplesIntegrator_exports.SamplesIntegrator.framesAreEqual(rootNodeEntry.callFrame, childNodeEntry.callFrame)) {
            repeatingNodes.push(childNode.entry);
          }
        } else if (!rootIsProfileCall && !childIsProfileCall) {
          if (root.entry.name === childNode.entry.name) {
            repeatingNodes.push(childNode.entry);
          }
        }
        children.push(...childNode.children);
      }
    }
    return repeatingNodes;
  }
  isEntryModified(event) {
    return this.#modifiedVisibleEntries.includes(event);
  }
  isUserApplyFilterAction(action) {
    return filterApplyActionSet.has(action.type);
  }
  isFilterUndoAction(action) {
    return filterUndoActionSet.has(action);
  }
};

// front_end/models/trace/trace.ts
import * as Extras from "./extras/extras.js";

// front_end/models/trace/handlers/handlers.ts
var handlers_exports = {};
__export(handlers_exports, {
  ModelHandlers: () => ModelHandlers_exports,
  Threads: () => Threads_exports,
  Types: () => types_exports2
});

// front_end/models/trace/handlers/ModelHandlers.ts
var ModelHandlers_exports = {};
__export(ModelHandlers_exports, {
  Animations: () => AnimationHandler_exports,
  AuctionWorklets: () => AuctionWorkletsHandler_exports,
  Frames: () => FramesHandler_exports,
  GPU: () => GPUHandler_exports,
  Initiators: () => InitiatorsHandler_exports,
  LargestImagePaint: () => LargestImagePaintHandler_exports,
  LargestTextPaint: () => LargestTextPaintHandler_exports,
  LayerTree: () => LayerTreeHandler_exports,
  LayoutShifts: () => LayoutShiftsHandler_exports,
  Memory: () => MemoryHandler_exports,
  Meta: () => MetaHandler_exports,
  NetworkRequests: () => NetworkRequestsHandler_exports,
  PageLoadMetrics: () => PageLoadMetricsHandler_exports,
  Renderer: () => RendererHandler_exports,
  Samples: () => SamplesHandler_exports,
  Screenshots: () => ScreenshotsHandler_exports,
  UserInteractions: () => UserInteractionsHandler_exports,
  UserTimings: () => UserTimingsHandler_exports,
  Warnings: () => WarningsHandler_exports,
  Workers: () => WorkersHandler_exports
});

// front_end/models/trace/handlers/AnimationHandler.ts
var AnimationHandler_exports = {};
__export(AnimationHandler_exports, {
  data: () => data,
  finalize: () => finalize,
  handleEvent: () => handleEvent,
  reset: () => reset
});

// front_end/models/trace/handlers/types.ts
var types_exports2 = {};
__export(types_exports2, {
  HandlerState: () => HandlerState,
  handlerDataHasAllHandlers: () => handlerDataHasAllHandlers
});
function handlerDataHasAllHandlers(data21) {
  let isMissingHandler = false;
  for (const handlerName of Object.keys(ModelHandlers_exports)) {
    if (handlerName in data21 === false) {
      isMissingHandler = true;
      break;
    }
  }
  return !isMissingHandler;
}
var HandlerState = /* @__PURE__ */ ((HandlerState2) => {
  HandlerState2[HandlerState2["UNINITIALIZED"] = 1] = "UNINITIALIZED";
  HandlerState2[HandlerState2["INITIALIZED"] = 2] = "INITIALIZED";
  HandlerState2[HandlerState2["FINALIZED"] = 3] = "FINALIZED";
  return HandlerState2;
})(HandlerState || {});

// front_end/models/trace/handlers/AnimationHandler.ts
var animations = [];
var animationsSyntheticEvents = [];
var handlerState = 1 /* UNINITIALIZED */;
function reset() {
  animations.length = 0;
  animationsSyntheticEvents.length = 0;
}
function handleEvent(event) {
  if (TraceEvents_exports.isTraceEventAnimation(event)) {
    animations.push(event);
    return;
  }
}
async function finalize() {
  const syntheticEvents2 = Trace_exports.createMatchedSortedSyntheticEvents(animations);
  animationsSyntheticEvents.push(...syntheticEvents2);
  handlerState = 3 /* FINALIZED */;
}
function data() {
  if (handlerState !== 3 /* FINALIZED */) {
    throw new Error("Animation handler is not finalized");
  }
  return {
    animations: Array.from(animationsSyntheticEvents)
  };
}

// front_end/models/trace/handlers/AuctionWorkletsHandler.ts
var AuctionWorkletsHandler_exports = {};
__export(AuctionWorkletsHandler_exports, {
  data: () => data2,
  finalize: () => finalize2,
  handleEvent: () => handleEvent2,
  reset: () => reset2
});
var runningInProcessEvents = /* @__PURE__ */ new Map();
var doneWithProcessEvents = /* @__PURE__ */ new Map();
var createdSyntheticEvents = /* @__PURE__ */ new Map();
var utilityThreads = /* @__PURE__ */ new Map();
var v8HelperThreads = /* @__PURE__ */ new Map();
function reset2() {
  runningInProcessEvents.clear();
  doneWithProcessEvents.clear();
  createdSyntheticEvents.clear();
  utilityThreads.clear();
  v8HelperThreads.clear();
}
function handleEvent2(event) {
  if (TraceEvents_exports.isTraceEventAuctionWorkletRunningInProcess(event)) {
    runningInProcessEvents.set(event.args.data.pid, event);
    return;
  }
  if (TraceEvents_exports.isTraceEventAuctionWorkletDoneWithProcess(event)) {
    doneWithProcessEvents.set(event.args.data.pid, event);
    return;
  }
  if (TraceEvents_exports.isThreadName(event)) {
    if (event.args.name === "auction_worklet.CrUtilityMain") {
      utilityThreads.set(event.pid, event);
      return;
    }
    if (event.args.name === "AuctionV8HelperThread") {
      v8HelperThreads.set(event.pid, event);
    }
  }
}
function workletType(input) {
  switch (input) {
    case "seller":
      return TraceEvents_exports.AuctionWorkletType.SELLER;
    case "bidder":
      return TraceEvents_exports.AuctionWorkletType.BIDDER;
    default:
      return TraceEvents_exports.AuctionWorkletType.UNKNOWN;
  }
}
function makeSyntheticEventBase(event) {
  return {
    name: "SyntheticAuctionWorkletEvent",
    s: TraceEvents_exports.TraceEventScope.THREAD,
    cat: event.cat,
    tid: event.tid,
    ts: event.ts,
    ph: TraceEvents_exports.Phase.INSTANT,
    pid: event.args.data.pid,
    host: event.args.data.host,
    target: event.args.data.target,
    type: workletType(event.args.data.type)
  };
}
async function finalize2() {
  for (const [pid, utilityThreadNameEvent] of utilityThreads) {
    const v8HelperEvent = v8HelperThreads.get(pid);
    if (!v8HelperEvent) {
      continue;
    }
    const runningEvent = runningInProcessEvents.get(pid);
    const doneWithEvent = doneWithProcessEvents.get(pid);
    let syntheticEvent = null;
    if (runningEvent) {
      syntheticEvent = {
        ...makeSyntheticEventBase(runningEvent),
        args: {
          data: {
            runningInProcessEvent: runningEvent,
            utilityThread: utilityThreadNameEvent,
            v8HelperThread: v8HelperEvent
          }
        }
      };
      if (doneWithEvent) {
        syntheticEvent.args.data.doneWithProcessEvent = doneWithEvent;
      }
    } else if (doneWithEvent) {
      syntheticEvent = {
        ...makeSyntheticEventBase(doneWithEvent),
        args: {
          data: {
            doneWithProcessEvent: doneWithEvent,
            utilityThread: utilityThreadNameEvent,
            v8HelperThread: v8HelperEvent
          }
        }
      };
      if (runningEvent) {
        syntheticEvent.args.data.runningInProcessEvent = runningEvent;
      }
    }
    if (syntheticEvent === null) {
      continue;
    }
    createdSyntheticEvents.set(pid, syntheticEvent);
  }
}
function data2() {
  return {
    worklets: new Map(createdSyntheticEvents)
  };
}

// front_end/models/trace/handlers/FramesHandler.ts
var FramesHandler_exports = {};
__export(FramesHandler_exports, {
  LayerPaintEvent: () => LayerPaintEvent,
  PendingFrame: () => PendingFrame,
  TimelineFrame: () => TimelineFrame,
  TimelineFrameBeginFrameQueue: () => TimelineFrameBeginFrameQueue,
  TimelineFrameModel: () => TimelineFrameModel,
  data: () => data7,
  deps: () => deps3,
  finalize: () => finalize7,
  handleEvent: () => handleEvent7,
  initialize: () => initialize5,
  reset: () => reset7
});

// front_end/models/trace/handlers/LayerTreeHandler.ts
var LayerTreeHandler_exports = {};
__export(LayerTreeHandler_exports, {
  data: () => data4,
  deps: () => deps,
  finalize: () => finalize4,
  handleEvent: () => handleEvent4,
  initialize: () => initialize2,
  reset: () => reset4
});

// front_end/models/trace/handlers/MetaHandler.ts
var MetaHandler_exports = {};
__export(MetaHandler_exports, {
  data: () => data3,
  finalize: () => finalize3,
  handleEvent: () => handleEvent3,
  initialize: () => initialize,
  reset: () => reset3
});
var rendererProcessesByFrameId = /* @__PURE__ */ new Map();
var mainFrameId = "";
var mainFrameURL = "";
var framesByProcessId = /* @__PURE__ */ new Map();
var browserProcessId = TraceEvents_exports.ProcessID(-1);
var browserThreadId = TraceEvents_exports.ThreadID(-1);
var gpuProcessId = TraceEvents_exports.ProcessID(-1);
var gpuThreadId = TraceEvents_exports.ThreadID(-1);
var viewportRect = null;
var topLevelRendererIds = /* @__PURE__ */ new Set();
var traceBounds = {
  min: Timing_exports2.MicroSeconds(Number.POSITIVE_INFINITY),
  max: Timing_exports2.MicroSeconds(Number.NEGATIVE_INFINITY),
  range: Timing_exports2.MicroSeconds(Number.POSITIVE_INFINITY)
};
var navigationsByFrameId = /* @__PURE__ */ new Map();
var navigationsByNavigationId = /* @__PURE__ */ new Map();
var mainFrameNavigations = [];
var threadsInProcess = /* @__PURE__ */ new Map();
var traceStartedTimeFromTracingStartedEvent = Timing_exports2.MicroSeconds(-1);
var eventPhasesOfInterestForTraceBounds = /* @__PURE__ */ new Set([
  TraceEvents_exports.Phase.BEGIN,
  TraceEvents_exports.Phase.END,
  TraceEvents_exports.Phase.COMPLETE,
  TraceEvents_exports.Phase.INSTANT
]);
var handlerState2 = 1 /* UNINITIALIZED */;
function reset3() {
  navigationsByFrameId.clear();
  navigationsByNavigationId.clear();
  mainFrameNavigations.length = 0;
  browserProcessId = TraceEvents_exports.ProcessID(-1);
  browserThreadId = TraceEvents_exports.ThreadID(-1);
  gpuProcessId = TraceEvents_exports.ProcessID(-1);
  gpuThreadId = TraceEvents_exports.ThreadID(-1);
  viewportRect = null;
  topLevelRendererIds.clear();
  threadsInProcess.clear();
  rendererProcessesByFrameId.clear();
  framesByProcessId.clear();
  traceBounds.min = Timing_exports2.MicroSeconds(Number.POSITIVE_INFINITY);
  traceBounds.max = Timing_exports2.MicroSeconds(Number.NEGATIVE_INFINITY);
  traceBounds.range = Timing_exports2.MicroSeconds(Number.POSITIVE_INFINITY);
  traceStartedTimeFromTracingStartedEvent = Timing_exports2.MicroSeconds(-1);
  handlerState2 = 1 /* UNINITIALIZED */;
}
function initialize() {
  if (handlerState2 !== 1 /* UNINITIALIZED */) {
    throw new Error("Meta Handler was not reset");
  }
  handlerState2 = 2 /* INITIALIZED */;
}
function updateRendererProcessByFrame(event, frame) {
  const framesInProcessById = map_utilities_exports.getWithDefault(framesByProcessId, frame.processId, () => /* @__PURE__ */ new Map());
  framesInProcessById.set(frame.frame, frame);
  const rendererProcessInFrame = map_utilities_exports.getWithDefault(rendererProcessesByFrameId, frame.frame, () => /* @__PURE__ */ new Map());
  const rendererProcessInfo = map_utilities_exports.getWithDefault(rendererProcessInFrame, frame.processId, () => {
    return [];
  });
  const lastProcessData = rendererProcessInfo.at(-1);
  if (lastProcessData && lastProcessData.frame.url === frame.url) {
    return;
  }
  rendererProcessInfo.push({
    frame,
    window: {
      min: event.ts,
      max: Timing_exports2.MicroSeconds(0),
      range: Timing_exports2.MicroSeconds(0)
    }
  });
}
function handleEvent3(event) {
  if (handlerState2 !== 2 /* INITIALIZED */) {
    throw new Error("Meta Handler is not initialized");
  }
  if (event.ts !== 0 && !event.name.endsWith("::UMA") && eventPhasesOfInterestForTraceBounds.has(event.ph)) {
    traceBounds.min = Timing_exports2.MicroSeconds(Math.min(event.ts, traceBounds.min));
    const eventDuration = event.dur || Timing_exports2.MicroSeconds(0);
    traceBounds.max = Timing_exports2.MicroSeconds(Math.max(event.ts + eventDuration, traceBounds.max));
  }
  if (TraceEvents_exports.isProcessName(event) && (event.args.name === "Browser" || event.args.name === "HeadlessBrowser")) {
    browserProcessId = event.pid;
    return;
  }
  if (TraceEvents_exports.isProcessName(event) && (event.args.name === "Gpu" || event.args.name === "GPU Process")) {
    gpuProcessId = event.pid;
    return;
  }
  if (TraceEvents_exports.isThreadName(event) && event.args.name === "CrGpuMain") {
    gpuThreadId = event.tid;
    return;
  }
  if (TraceEvents_exports.isThreadName(event) && event.args.name === "CrBrowserMain") {
    browserThreadId = event.tid;
  }
  if (TraceEvents_exports.isTraceEventMainFrameViewport(event) && viewportRect === null) {
    const rectAsArray = event.args.data.viewport_rect;
    const viewportX = rectAsArray[0];
    const viewportY = rectAsArray[1];
    const viewportWidth = rectAsArray[2];
    const viewportHeight = rectAsArray[5];
    viewportRect = new DOMRect(viewportX, viewportY, viewportWidth, viewportHeight);
  }
  if (TraceEvents_exports.isTraceEventTracingStartedInBrowser(event)) {
    traceStartedTimeFromTracingStartedEvent = event.ts;
    if (!event.args.data) {
      throw new Error("No frames found in trace data");
    }
    for (const frame of event.args.data.frames ?? []) {
      updateRendererProcessByFrame(event, frame);
      if (frame.parent) {
        continue;
      }
      mainFrameId = frame.frame;
      mainFrameURL = frame.url;
      topLevelRendererIds.add(frame.processId);
    }
    return;
  }
  if (TraceEvents_exports.isTraceEventFrameCommittedInBrowser(event)) {
    const frame = event.args.data;
    if (!frame) {
      return;
    }
    updateRendererProcessByFrame(event, frame);
    if (frame.parent) {
      return;
    }
    topLevelRendererIds.add(frame.processId);
    return;
  }
  if (TraceEvents_exports.isTraceEventCommitLoad(event)) {
    const frameData = event.args.data;
    if (!frameData) {
      return;
    }
    const { frame, name, url } = frameData;
    updateRendererProcessByFrame(event, { processId: event.pid, frame, name, url });
    return;
  }
  if (TraceEvents_exports.isThreadName(event)) {
    const threads = map_utilities_exports.getWithDefault(threadsInProcess, event.pid, () => /* @__PURE__ */ new Map());
    threads.set(event.tid, event);
    return;
  }
  if (TraceEvents_exports.isTraceEventNavigationStartWithURL(event) && event.args.data) {
    const navigationId = event.args.data.navigationId;
    if (navigationsByNavigationId.has(navigationId)) {
      throw new Error("Found multiple navigation start events with the same navigation ID.");
    }
    navigationsByNavigationId.set(navigationId, event);
    const frameId = event.args.frame;
    const existingFrameNavigations = navigationsByFrameId.get(frameId) || [];
    existingFrameNavigations.push(event);
    navigationsByFrameId.set(frameId, existingFrameNavigations);
    if (frameId === mainFrameId) {
      mainFrameNavigations.push(event);
    }
    return;
  }
}
async function finalize3() {
  if (handlerState2 !== 2 /* INITIALIZED */) {
    throw new Error("Handler is not initialized");
  }
  if (traceStartedTimeFromTracingStartedEvent >= 0) {
    traceBounds.min = traceStartedTimeFromTracingStartedEvent;
  }
  traceBounds.range = Timing_exports2.MicroSeconds(traceBounds.max - traceBounds.min);
  for (const [, processWindows] of rendererProcessesByFrameId) {
    const processWindowValues = [...processWindows.values()].flat();
    for (let i = 0; i < processWindowValues.length; i++) {
      const currentWindow = processWindowValues[i];
      const nextWindow = processWindowValues[i + 1];
      if (!nextWindow) {
        currentWindow.window.max = Timing_exports2.MicroSeconds(traceBounds.max);
        currentWindow.window.range = Timing_exports2.MicroSeconds(traceBounds.max - currentWindow.window.min);
      } else {
        currentWindow.window.max = Timing_exports2.MicroSeconds(nextWindow.window.min - 1);
        currentWindow.window.range = Timing_exports2.MicroSeconds(currentWindow.window.max - currentWindow.window.min);
      }
    }
  }
  for (const [frameId, navigations] of navigationsByFrameId) {
    if (rendererProcessesByFrameId.has(frameId)) {
      continue;
    }
    navigationsByFrameId.delete(frameId);
    for (const navigation of navigations) {
      if (!navigation.args.data) {
        continue;
      }
      navigationsByNavigationId.delete(navigation.args.data.navigationId);
    }
  }
  handlerState2 = 3 /* FINALIZED */;
}
function data3() {
  if (handlerState2 !== 3 /* FINALIZED */) {
    throw new Error("Meta Handler is not finalized");
  }
  return {
    traceBounds: { ...traceBounds },
    browserProcessId,
    browserThreadId,
    gpuProcessId,
    gpuThreadId: gpuThreadId === TraceEvents_exports.ThreadID(-1) ? void 0 : gpuThreadId,
    viewportRect: viewportRect || void 0,
    mainFrameId,
    mainFrameURL,
    navigationsByFrameId: new Map(navigationsByFrameId),
    navigationsByNavigationId: new Map(navigationsByNavigationId),
    threadsInProcess: new Map(threadsInProcess),
    rendererProcessesByFrame: new Map(rendererProcessesByFrameId),
    topLevelRendererIds: new Set(topLevelRendererIds),
    frameByProcessId: new Map(framesByProcessId),
    mainFrameNavigations: [...mainFrameNavigations]
  };
}

// front_end/models/trace/handlers/LayerTreeHandler.ts
var handlerState3 = 1 /* UNINITIALIZED */;
var paintEvents = [];
var snapshotEvents = [];
var paintToSnapshotMap = /* @__PURE__ */ new Map();
var lastPaintForLayerId = {};
var currentMainFrameLayerTreeId = null;
var updateLayerEvents = [];
var relevantEvents = [];
function reset4() {
  handlerState3 = 1 /* UNINITIALIZED */;
  paintEvents.length = 0;
  snapshotEvents.length = 0;
  paintToSnapshotMap.clear();
  lastPaintForLayerId = {};
  currentMainFrameLayerTreeId = null;
  updateLayerEvents.length = 0;
  relevantEvents.length = 0;
}
function initialize2() {
  if (handlerState3 !== 1 /* UNINITIALIZED */) {
    throw new Error("LayerTree Handler was not reset before being initialized");
  }
  handlerState3 = 2 /* INITIALIZED */;
}
function handleEvent4(event) {
  if (TraceEvents_exports.isTraceEventPaint(event) || TraceEvents_exports.isTraceEventDisplayListItemListSnapshot(event) || TraceEvents_exports.isTraceEventUpdateLayer(event) || TraceEvents_exports.isTraceEventSetLayerId(event)) {
    relevantEvents.push(event);
  }
}
async function finalize4() {
  if (handlerState3 !== 2 /* INITIALIZED */) {
    throw new Error("LayerTree Handler is not initialized");
  }
  const metaData = data3();
  Trace_exports.sortTraceEventsInPlace(relevantEvents);
  for (const event of relevantEvents) {
    if (TraceEvents_exports.isTraceEventSetLayerId(event)) {
      if (metaData.mainFrameId !== event.args.data.frame) {
        continue;
      }
      currentMainFrameLayerTreeId = event.args.data.layerTreeId;
    } else if (TraceEvents_exports.isTraceEventUpdateLayer(event)) {
      updateLayerEvents.push(event);
    } else if (TraceEvents_exports.isTraceEventPaint(event)) {
      if (!event.args.data.layerId) {
        continue;
      }
      paintEvents.push(event);
      lastPaintForLayerId[event.args.data.layerId] = event;
      continue;
    } else if (TraceEvents_exports.isTraceEventDisplayListItemListSnapshot(event)) {
      let lastUpdateLayerEventForThread = null;
      for (let i = updateLayerEvents.length - 1; i > -1; i--) {
        const updateEvent = updateLayerEvents[i];
        if (updateEvent.pid === event.pid && updateEvent.tid === event.tid) {
          lastUpdateLayerEventForThread = updateEvent;
          break;
        }
      }
      if (!lastUpdateLayerEventForThread) {
        continue;
      }
      if (lastUpdateLayerEventForThread.args.layerTreeId !== currentMainFrameLayerTreeId) {
        continue;
      }
      const paintEvent = lastPaintForLayerId[lastUpdateLayerEventForThread.args.layerId];
      if (!paintEvent) {
        continue;
      }
      snapshotEvents.push(event);
      paintToSnapshotMap.set(paintEvent, event);
    }
  }
  handlerState3 = 3 /* FINALIZED */;
}
function data4() {
  return {
    paints: Array.from(paintEvents),
    snapshots: Array.from(snapshotEvents),
    paintsToSnapshots: new Map(paintToSnapshotMap)
  };
}
function deps() {
  return ["Meta"];
}

// front_end/models/trace/handlers/RendererHandler.ts
var RendererHandler_exports = {};
__export(RendererHandler_exports, {
  assignIsMainFrame: () => assignIsMainFrame,
  assignMeta: () => assignMeta,
  assignOrigin: () => assignOrigin,
  assignThreadName: () => assignThreadName,
  buildHierarchy: () => buildHierarchy,
  data: () => data6,
  deps: () => deps2,
  finalize: () => finalize6,
  handleEvent: () => handleEvent6,
  handleUserConfig: () => handleUserConfig,
  initialize: () => initialize4,
  makeCompleteEvent: () => makeCompleteEvent,
  reset: () => reset6,
  sanitizeProcesses: () => sanitizeProcesses,
  sanitizeThreads: () => sanitizeThreads
});

// front_end/models/trace/handlers/SamplesHandler.ts
var SamplesHandler_exports = {};
__export(SamplesHandler_exports, {
  data: () => data5,
  finalize: () => finalize5,
  getProfileCallFunctionName: () => getProfileCallFunctionName,
  handleEvent: () => handleEvent5,
  initialize: () => initialize3,
  reset: () => reset5
});

// front_end/models/cpu_profile/CPUProfileDataModel.ts
var CPUProfileDataModel_exports = {};
__export(CPUProfileDataModel_exports, {
  CPUProfileDataModel: () => CPUProfileDataModel,
  CPUProfileNode: () => CPUProfileNode
});

// front_end/models/cpu_profile/ProfileTreeModel.ts
var ProfileNode = class {
  callFrame;
  callUID;
  self;
  total;
  id;
  parent;
  children;
  functionName;
  depth;
  deoptReason;
  constructor(callFrame) {
    this.callFrame = callFrame;
    this.callUID = `${callFrame.functionName}@${callFrame.scriptId}:${callFrame.lineNumber}:${callFrame.columnNumber}`;
    this.self = 0;
    this.total = 0;
    this.id = 0;
    this.functionName = callFrame.functionName;
    this.parent = null;
    this.children = [];
  }
  get scriptId() {
    return String(this.callFrame.scriptId);
  }
  get url() {
    return this.callFrame.url;
  }
  get lineNumber() {
    return this.callFrame.lineNumber;
  }
  get columnNumber() {
    return this.callFrame.columnNumber;
  }
  setFunctionName(name) {
    if (name === null) {
      return;
    }
    this.functionName = name;
  }
};
var ProfileTreeModel = class {
  root;
  total;
  maxDepth;
  constructor() {
  }
  initialize(root) {
    this.root = root;
    this.assignDepthsAndParents();
    this.total = this.calculateTotals(this.root);
  }
  assignDepthsAndParents() {
    const root = this.root;
    root.depth = -1;
    root.parent = null;
    this.maxDepth = 0;
    const nodesToTraverse = [root];
    while (nodesToTraverse.length) {
      const parent = nodesToTraverse.pop();
      const depth = parent.depth + 1;
      if (depth > this.maxDepth) {
        this.maxDepth = depth;
      }
      const children = parent.children;
      for (const child of children) {
        child.depth = depth;
        child.parent = parent;
        nodesToTraverse.push(child);
      }
    }
  }
  calculateTotals(root) {
    const nodesToTraverse = [root];
    const dfsList = [];
    while (nodesToTraverse.length) {
      const node = nodesToTraverse.pop();
      node.total = node.self;
      dfsList.push(node);
      nodesToTraverse.push(...node.children);
    }
    while (dfsList.length > 1) {
      const node = dfsList.pop();
      if (node.parent) {
        node.parent.total += node.total;
      }
    }
    return root.total;
  }
};

// front_end/models/cpu_profile/CPUProfileDataModel.ts
var CPUProfileNode = class extends ProfileNode {
  id;
  self;
  positionTicks;
  deoptReason;
  constructor(node, samplingInterval) {
    const callFrame = node.callFrame || {
      functionName: node["functionName"],
      scriptId: node["scriptId"],
      url: node["url"],
      lineNumber: node["lineNumber"] - 1,
      columnNumber: node["columnNumber"] - 1
    };
    super(callFrame);
    this.id = node.id;
    this.self = (node.hitCount || 0) * samplingInterval;
    this.positionTicks = node.positionTicks;
    this.deoptReason = node.deoptReason && node.deoptReason !== "no reason" ? node.deoptReason : null;
  }
};
var CPUProfileDataModel = class extends ProfileTreeModel {
  profileStartTime;
  profileEndTime;
  timestamps;
  samples;
  lines;
  totalHitCount;
  profileHead;
  #idToParsedNode;
  gcNode;
  programNode;
  idleNode;
  #stackStartTimes;
  #stackChildrenDuration;
  constructor(profile) {
    super();
    const isLegacyFormat = Boolean(profile["head"]);
    if (isLegacyFormat) {
      this.profileStartTime = profile.startTime * 1e3;
      this.profileEndTime = profile.endTime * 1e3;
      this.timestamps = profile.timestamps;
      this.compatibilityConversionHeadToNodes(profile);
    } else {
      this.profileStartTime = profile.startTime / 1e3;
      this.profileEndTime = profile.endTime / 1e3;
      this.timestamps = this.convertTimeDeltas(profile);
    }
    this.samples = profile.samples;
    this.lines = profile.lines;
    this.totalHitCount = 0;
    this.profileHead = this.translateProfileTree(profile.nodes);
    this.initialize(this.profileHead);
    this.extractMetaNodes();
    if (this.samples?.length) {
      this.sortSamples();
      this.normalizeTimestamps();
      this.fixMissingSamples();
    }
  }
  compatibilityConversionHeadToNodes(profile) {
    if (!profile.head || profile.nodes) {
      return;
    }
    const nodes = [];
    convertNodesTree(profile.head);
    profile.nodes = nodes;
    delete profile.head;
    function convertNodesTree(node) {
      nodes.push(node);
      node.children = node.children.map(convertNodesTree);
      return node.id;
    }
  }
  convertTimeDeltas(profile) {
    if (!profile.timeDeltas) {
      return [];
    }
    let lastTimeMicroSec = profile.startTime;
    const timestamps = new Array(profile.timeDeltas.length);
    for (let i = 0; i < profile.timeDeltas.length; ++i) {
      lastTimeMicroSec += profile.timeDeltas[i];
      timestamps[i] = lastTimeMicroSec;
    }
    return timestamps;
  }
  translateProfileTree(nodes) {
    function buildChildrenFromParents(nodes2) {
      if (nodes2[0].children) {
        return;
      }
      nodes2[0].children = [];
      for (let i = 1; i < nodes2.length; ++i) {
        const node = nodes2[i];
        const parentNode = protocolNodeById.get(node.parent);
        if (parentNode.children) {
          parentNode.children.push(node.id);
        } else {
          parentNode.children = [node.id];
        }
      }
    }
    function buildHitCountFromSamples(nodes2, samples) {
      if (typeof nodes2[0].hitCount === "number") {
        return;
      }
      if (!samples) {
        throw new Error("Error: Neither hitCount nor samples are present in profile.");
      }
      for (let i = 0; i < nodes2.length; ++i) {
        nodes2[i].hitCount = 0;
      }
      for (let i = 0; i < samples.length; ++i) {
        const node = protocolNodeById.get(samples[i]);
        if (!node || node.hitCount === void 0) {
          continue;
        }
        node.hitCount++;
      }
    }
    const protocolNodeById = /* @__PURE__ */ new Map();
    for (let i = 0; i < nodes.length; ++i) {
      const node = nodes[i];
      protocolNodeById.set(node.id, node);
    }
    buildHitCountFromSamples(nodes, this.samples);
    buildChildrenFromParents(nodes);
    this.totalHitCount = nodes.reduce((acc, node) => acc + (node.hitCount || 0), 0);
    const sampleTime = (this.profileEndTime - this.profileStartTime) / this.totalHitCount;
    const root = nodes[0];
    const idToUseForRemovedNode = /* @__PURE__ */ new Map([[root.id, root.id]]);
    this.#idToParsedNode = /* @__PURE__ */ new Map();
    const resultRoot = new CPUProfileNode(root, sampleTime);
    this.#idToParsedNode.set(root.id, resultRoot);
    if (!root.children) {
      throw new Error("Missing children for root");
    }
    const parentNodeStack = root.children.map(() => resultRoot);
    const sourceNodeStack = root.children.map((id) => protocolNodeById.get(id));
    while (sourceNodeStack.length) {
      let parentNode = parentNodeStack.pop();
      const sourceNode = sourceNodeStack.pop();
      if (!sourceNode || !parentNode) {
        continue;
      }
      if (!sourceNode.children) {
        sourceNode.children = [];
      }
      const targetNode = new CPUProfileNode(sourceNode, sampleTime);
      parentNode.children.push(targetNode);
      parentNode = targetNode;
      idToUseForRemovedNode.set(sourceNode.id, parentNode.id);
      parentNodeStack.push.apply(parentNodeStack, sourceNode.children.map(() => parentNode));
      sourceNodeStack.push.apply(sourceNodeStack, sourceNode.children.map((id) => protocolNodeById.get(id)));
      this.#idToParsedNode.set(sourceNode.id, targetNode);
    }
    if (this.samples) {
      this.samples = this.samples.map((id) => idToUseForRemovedNode.get(id));
    }
    return resultRoot;
  }
  sortSamples() {
    if (!this.timestamps || !this.samples) {
      return;
    }
    const timestamps = this.timestamps;
    const samples = this.samples;
    const orderedIndices = timestamps.map((_x, index) => index);
    orderedIndices.sort((a, b) => timestamps[a] - timestamps[b]);
    this.timestamps = [];
    this.samples = [];
    for (let i = 0; i < orderedIndices.length; i++) {
      const orderedIndex = orderedIndices[i];
      this.timestamps.push(timestamps[orderedIndex]);
      this.samples.push(samples[orderedIndex]);
    }
  }
  normalizeTimestamps() {
    if (!this.samples) {
      return;
    }
    let timestamps = this.timestamps;
    if (!timestamps) {
      const profileStartTime = this.profileStartTime;
      const interval = (this.profileEndTime - profileStartTime) / this.samples.length;
      timestamps = new Array(this.samples.length + 1);
      for (let i = 0; i < timestamps.length; ++i) {
        timestamps[i] = profileStartTime + i * interval;
      }
      this.timestamps = timestamps;
      return;
    }
    for (let i = 0; i < timestamps.length; ++i) {
      timestamps[i] /= 1e3;
    }
    if (this.samples.length === timestamps.length) {
      const lastTimestamp = timestamps.at(-1) || 0;
      const averageIntervalTime = (lastTimestamp - timestamps[0]) / (timestamps.length - 1);
      this.timestamps.push(lastTimestamp + averageIntervalTime);
    }
    this.profileStartTime = timestamps.at(0) || this.profileStartTime;
    this.profileEndTime = timestamps.at(-1) || this.profileEndTime;
  }
  extractMetaNodes() {
    const topLevelNodes = this.profileHead.children;
    for (let i = 0; i < topLevelNodes.length && !(this.gcNode && this.programNode && this.idleNode); i++) {
      const node = topLevelNodes[i];
      if (node.functionName === "(garbage collector)") {
        this.gcNode = node;
      } else if (node.functionName === "(program)") {
        this.programNode = node;
      } else if (node.functionName === "(idle)") {
        this.idleNode = node;
      }
    }
  }
  fixMissingSamples() {
    const samples = this.samples;
    if (!samples) {
      return;
    }
    const samplesCount = samples.length;
    if (!this.programNode || samplesCount < 3) {
      return;
    }
    const idToNode = this.#idToParsedNode;
    const programNodeId = this.programNode.id;
    const gcNodeId = this.gcNode ? this.gcNode.id : -1;
    const idleNodeId = this.idleNode ? this.idleNode.id : -1;
    let prevNodeId = samples[0];
    let nodeId = samples[1];
    for (let sampleIndex = 1; sampleIndex < samplesCount - 1; sampleIndex++) {
      const nextNodeId = samples[sampleIndex + 1];
      const prevNode = idToNode.get(prevNodeId);
      const nextNode = idToNode.get(nextNodeId);
      if (prevNodeId === void 0 || nextNodeId === void 0 || !prevNode || !nextNode) {
        console.error(`Unexpectedly found undefined nodes: ${prevNodeId} ${nextNodeId}`);
        continue;
      }
      if (nodeId === programNodeId && !isSystemNode(prevNodeId) && !isSystemNode(nextNodeId) && bottomNode(prevNode) === bottomNode(nextNode)) {
        samples[sampleIndex] = prevNodeId;
      }
      prevNodeId = nodeId;
      nodeId = nextNodeId;
    }
    function bottomNode(node) {
      while (node.parent && node.parent.parent) {
        node = node.parent;
      }
      return node;
    }
    function isSystemNode(nodeId2) {
      return nodeId2 === programNodeId || nodeId2 === gcNodeId || nodeId2 === idleNodeId;
    }
  }
  forEachFrame(openFrameCallback, closeFrameCallback, startTime, stopTime) {
    if (!this.profileHead || !this.samples) {
      return;
    }
    startTime = startTime || 0;
    stopTime = stopTime || Infinity;
    const samples = this.samples;
    const timestamps = this.timestamps;
    const idToNode = this.#idToParsedNode;
    const gcNode = this.gcNode;
    const samplesCount = samples.length;
    const startIndex = array_utilities_exports.lowerBound(timestamps, startTime, array_utilities_exports.DEFAULT_COMPARATOR);
    let stackTop = 0;
    const stackNodes = [];
    let prevId = this.profileHead.id;
    let sampleTime;
    let gcParentNode = null;
    const stackDepth = this.maxDepth + 3;
    if (!this.#stackStartTimes) {
      this.#stackStartTimes = new Array(stackDepth);
    }
    const stackStartTimes = this.#stackStartTimes;
    if (!this.#stackChildrenDuration) {
      this.#stackChildrenDuration = new Array(stackDepth);
    }
    const stackChildrenDuration = this.#stackChildrenDuration;
    let node;
    let sampleIndex;
    for (sampleIndex = startIndex; sampleIndex < samplesCount; sampleIndex++) {
      sampleTime = timestamps[sampleIndex];
      if (sampleTime >= stopTime) {
        break;
      }
      const id = samples[sampleIndex];
      if (id === prevId) {
        continue;
      }
      node = idToNode.get(id);
      let prevNode = idToNode.get(prevId) || null;
      if (!prevNode) {
        continue;
      }
      if (gcNode && node === gcNode) {
        gcParentNode = prevNode;
        openFrameCallback(gcParentNode.depth + 1, gcNode, sampleTime);
        stackStartTimes[++stackTop] = sampleTime;
        stackChildrenDuration[stackTop] = 0;
        prevId = id;
        continue;
      }
      if (gcNode && prevNode === gcNode && gcParentNode) {
        const start = stackStartTimes[stackTop];
        const duration = sampleTime - start;
        stackChildrenDuration[stackTop - 1] += duration;
        closeFrameCallback(gcParentNode.depth + 1, gcNode, start, duration, duration - stackChildrenDuration[stackTop]);
        --stackTop;
        prevNode = gcParentNode;
        prevId = prevNode.id;
        gcParentNode = null;
      }
      while (node && node.depth > prevNode.depth) {
        stackNodes.push(node);
        node = node.parent;
      }
      while (prevNode && prevNode !== node) {
        const start = stackStartTimes[stackTop];
        const duration = sampleTime - start;
        stackChildrenDuration[stackTop - 1] += duration;
        closeFrameCallback(prevNode.depth, prevNode, start, duration, duration - stackChildrenDuration[stackTop]);
        --stackTop;
        if (node && node.depth === prevNode.depth) {
          stackNodes.push(node);
          node = node.parent;
        }
        prevNode = prevNode.parent;
      }
      while (stackNodes.length) {
        const currentNode = stackNodes.pop();
        if (!currentNode) {
          break;
        }
        node = currentNode;
        openFrameCallback(currentNode.depth, currentNode, sampleTime);
        stackStartTimes[++stackTop] = sampleTime;
        stackChildrenDuration[stackTop] = 0;
      }
      prevId = id;
    }
    sampleTime = timestamps[sampleIndex] || this.profileEndTime;
    if (node && gcParentNode && idToNode.get(prevId) === gcNode) {
      const start = stackStartTimes[stackTop];
      const duration = sampleTime - start;
      stackChildrenDuration[stackTop - 1] += duration;
      closeFrameCallback(gcParentNode.depth + 1, node, start, duration, duration - stackChildrenDuration[stackTop]);
      --stackTop;
      prevId = gcParentNode.id;
    }
    for (let node2 = idToNode.get(prevId); node2 && node2.parent; node2 = node2.parent) {
      const start = stackStartTimes[stackTop];
      const duration = sampleTime - start;
      stackChildrenDuration[stackTop - 1] += duration;
      closeFrameCallback(node2.depth, node2, start, duration, duration - stackChildrenDuration[stackTop]);
      --stackTop;
    }
  }
  nodeByIndex(index) {
    return this.samples && this.#idToParsedNode.get(this.samples[index]) || null;
  }
  nodeById(nodeId) {
    return this.#idToParsedNode.get(nodeId) || null;
  }
  nodes() {
    if (!this.#idToParsedNode) {
      return null;
    }
    return [...this.#idToParsedNode.values()];
  }
};

// front_end/models/trace/handlers/SamplesHandler.ts
var events = /* @__PURE__ */ new Map();
var profilesInProcess = /* @__PURE__ */ new Map();
var entryToNode = /* @__PURE__ */ new Map();
var preprocessedData = /* @__PURE__ */ new Map();
var handlerState4 = 1 /* UNINITIALIZED */;
function buildProfileCalls() {
  for (const [processId, profiles] of preprocessedData) {
    for (const [profileId, preProcessedData] of profiles) {
      let openFrameCallback = function(depth, node, timeStampMs) {
        if (threadId === void 0) {
          return;
        }
        const ts = Timing_exports3.millisecondsToMicroseconds(Timing_exports2.MilliSeconds(timeStampMs));
        const nodeId = node.id;
        const profileCall = Trace_exports.makeProfileCall(node, ts, processId, threadId);
        finalizedData.profileCalls.push(profileCall);
        indexStack.push(finalizedData.profileCalls.length - 1);
        const traceEntryNode = TreeHelpers_exports.makeEmptyTraceEntryNode(profileCall, nodeId);
        entryToNode.set(profileCall, traceEntryNode);
        traceEntryNode.depth = depth;
        if (indexStack.length === 1) {
          finalizedData.profileTree?.roots.add(traceEntryNode);
        }
      }, closeFrameCallback = function(_depth, node, _timeStamp, durMs, selfTimeMs) {
        const profileCallIndex = indexStack.pop();
        const profileCall = profileCallIndex !== void 0 && finalizedData.profileCalls[profileCallIndex];
        if (!profileCall) {
          return;
        }
        const { callFrame, ts, pid, tid } = profileCall;
        const traceEntryNode = entryToNode.get(profileCall);
        if (callFrame === void 0 || ts === void 0 || pid === void 0 || profileId === void 0 || tid === void 0 || traceEntryNode === void 0) {
          return;
        }
        const dur = Timing_exports3.millisecondsToMicroseconds(Timing_exports2.MilliSeconds(durMs));
        const selfTime = Timing_exports3.millisecondsToMicroseconds(Timing_exports2.MilliSeconds(selfTimeMs));
        profileCall.dur = dur;
        profileCall.selfTime = selfTime;
        const parentIndex = indexStack.at(-1);
        const parent = parentIndex !== void 0 && finalizedData.profileCalls.at(parentIndex);
        const parentNode = parent && entryToNode.get(parent);
        if (!parentNode) {
          return;
        }
        traceEntryNode.parent = parentNode;
        parentNode.children.push(traceEntryNode);
      };
      const threadId = preProcessedData.threadId;
      if (!preProcessedData.rawProfile.nodes.length || threadId === void 0) {
        continue;
      }
      const indexStack = [];
      const profileModel = new CPUProfileDataModel_exports.CPUProfileDataModel(preProcessedData.rawProfile);
      const profileTree = TreeHelpers_exports.makeEmptyTraceEntryTree();
      profileTree.maxDepth = profileModel.maxDepth;
      const finalizedData = { rawProfile: preProcessedData.rawProfile, parsedProfile: profileModel, profileCalls: [], profileTree };
      const dataByThread = map_utilities_exports.getWithDefault(profilesInProcess, processId, () => /* @__PURE__ */ new Map());
      profileModel.forEachFrame(openFrameCallback, closeFrameCallback);
      dataByThread.set(threadId, finalizedData);
    }
  }
}
function reset5() {
  events.clear();
  preprocessedData.clear();
  profilesInProcess.clear();
  entryToNode.clear();
  handlerState4 = 1 /* UNINITIALIZED */;
}
function initialize3() {
  if (handlerState4 !== 1 /* UNINITIALIZED */) {
    throw new Error("Samples Handler was not reset");
  }
  handlerState4 = 2 /* INITIALIZED */;
}
function handleEvent5(event) {
  if (handlerState4 !== 2 /* INITIALIZED */) {
    throw new Error("Samples Handler is not initialized");
  }
  if (TraceEvents_exports.isSyntheticTraceEventCpuProfile(event)) {
    const pid = event.pid;
    const tid = event.tid;
    const profileId = "0x1";
    const profileData = getOrCreatePreProcessedData(pid, profileId);
    profileData.rawProfile = event.args.data.cpuProfile;
    profileData.threadId = tid;
    return;
  }
  if (TraceEvents_exports.isTraceEventProfile(event)) {
    const profileData = getOrCreatePreProcessedData(event.pid, event.id);
    profileData.rawProfile.startTime = event.ts;
    profileData.threadId = event.tid;
    return;
  }
  if (TraceEvents_exports.isTraceEventProfileChunk(event)) {
    const profileData = getOrCreatePreProcessedData(event.pid, event.id);
    const cdpProfile = profileData.rawProfile;
    const nodesAndSamples = event.args?.data?.cpuProfile || { samples: [] };
    const samples = nodesAndSamples?.samples || [];
    const nodes = [];
    for (const n of nodesAndSamples?.nodes || []) {
      const lineNumber = typeof n.callFrame.lineNumber === "undefined" ? -1 : n.callFrame.lineNumber;
      const columnNumber = typeof n.callFrame.columnNumber === "undefined" ? -1 : n.callFrame.columnNumber;
      const scriptId = String(n.callFrame.scriptId);
      const url = n.callFrame.url || "";
      const node = {
        ...n,
        callFrame: {
          ...n.callFrame,
          url,
          lineNumber,
          columnNumber,
          scriptId
        }
      };
      nodes.push(node);
    }
    const timeDeltas = event.args.data?.timeDeltas || [];
    const lines = event.args.data?.lines || Array(samples.length).fill(0);
    cdpProfile.nodes.push(...nodes);
    cdpProfile.samples?.push(...samples);
    cdpProfile.timeDeltas?.push(...timeDeltas);
    cdpProfile.lines?.push(...lines);
    if (cdpProfile.samples && cdpProfile.timeDeltas && cdpProfile.samples.length !== cdpProfile.timeDeltas.length) {
      console.error("Failed to parse CPU profile.");
      return;
    }
    if (!cdpProfile.endTime && cdpProfile.timeDeltas) {
      const timeDeltas2 = cdpProfile.timeDeltas;
      cdpProfile.endTime = timeDeltas2.reduce((x, y) => x + y, cdpProfile.startTime);
    }
    return;
  }
}
async function finalize5() {
  if (handlerState4 !== 2 /* INITIALIZED */) {
    throw new Error("Samples Handler is not initialized");
  }
  buildProfileCalls();
  handlerState4 = 3 /* FINALIZED */;
}
function data5() {
  if (handlerState4 !== 3 /* FINALIZED */) {
    throw new Error("Samples Handler is not finalized");
  }
  return {
    profilesInProcess: new Map(profilesInProcess),
    entryToNode: new Map(entryToNode)
  };
}
function getOrCreatePreProcessedData(processId, profileId) {
  const profileById = map_utilities_exports.getWithDefault(preprocessedData, processId, () => /* @__PURE__ */ new Map());
  return map_utilities_exports.getWithDefault(profileById, profileId, () => ({
    rawProfile: {
      startTime: 0,
      endTime: 0,
      nodes: [],
      samples: [],
      timeDeltas: [],
      lines: []
    },
    profileId
  }));
}
function getProfileCallFunctionName(data21, entry) {
  const profile = data21.profilesInProcess.get(entry.pid)?.get(entry.tid);
  const node = profile?.parsedProfile.nodeById(entry.nodeId);
  if (node?.functionName) {
    return node.functionName;
  }
  return entry.callFrame.functionName;
}

// front_end/models/trace/handlers/RendererHandler.ts
var processes = /* @__PURE__ */ new Map();
var compositorTileWorkers = Array();
var entryToNode2 = /* @__PURE__ */ new Map();
var allTraceEntries = [];
var completeEventStack = [];
var handlerState5 = 1 /* UNINITIALIZED */;
var config = Configuration_exports.DEFAULT;
var makeRendererProcess = () => ({
  url: null,
  isOnMainFrame: false,
  threads: /* @__PURE__ */ new Map()
});
var makeRendererThread = () => ({
  name: null,
  entries: []
});
var getOrCreateRendererProcess = (processes2, pid) => {
  return map_utilities_exports.getWithDefault(processes2, pid, makeRendererProcess);
};
var getOrCreateRendererThread = (process, tid) => {
  return map_utilities_exports.getWithDefault(process.threads, tid, makeRendererThread);
};
function handleUserConfig(userConfig) {
  config = userConfig;
}
function reset6() {
  processes.clear();
  entryToNode2.clear();
  allTraceEntries.length = 0;
  completeEventStack.length = 0;
  compositorTileWorkers.length = 0;
  handlerState5 = 1 /* UNINITIALIZED */;
}
function initialize4() {
  if (handlerState5 !== 1 /* UNINITIALIZED */) {
    throw new Error("Renderer Handler was not reset");
  }
  handlerState5 = 2 /* INITIALIZED */;
}
function handleEvent6(event) {
  if (handlerState5 !== 2 /* INITIALIZED */) {
    throw new Error("Renderer Handler is not initialized");
  }
  if (TraceEvents_exports.isThreadName(event) && event.args.name?.startsWith("CompositorTileWorker")) {
    compositorTileWorkers.push({
      pid: event.pid,
      tid: event.tid
    });
  }
  if (TraceEvents_exports.isTraceEventBegin(event) || TraceEvents_exports.isTraceEventEnd(event)) {
    const process = getOrCreateRendererProcess(processes, event.pid);
    const thread = getOrCreateRendererThread(process, event.tid);
    const completeEvent = makeCompleteEvent(event);
    if (!completeEvent) {
      return;
    }
    thread.entries.push(completeEvent);
    allTraceEntries.push(completeEvent);
    return;
  }
  if (TraceEvents_exports.isTraceEventInstant(event) || TraceEvents_exports.isTraceEventComplete(event)) {
    const process = getOrCreateRendererProcess(processes, event.pid);
    const thread = getOrCreateRendererThread(process, event.tid);
    thread.entries.push(event);
    allTraceEntries.push(event);
  }
}
async function finalize6() {
  if (handlerState5 !== 2 /* INITIALIZED */) {
    throw new Error("Renderer Handler is not initialized");
  }
  const { mainFrameId: mainFrameId2, rendererProcessesByFrame, threadsInProcess: threadsInProcess2 } = data3();
  assignMeta(processes, mainFrameId2, rendererProcessesByFrame, threadsInProcess2);
  sanitizeProcesses(processes);
  buildHierarchy(processes);
  sanitizeThreads(processes);
  Trace_exports.sortTraceEventsInPlace(allTraceEntries);
  handlerState5 = 3 /* FINALIZED */;
}
function data6() {
  if (handlerState5 !== 3 /* FINALIZED */) {
    throw new Error("Renderer Handler is not finalized");
  }
  return {
    processes: new Map(processes),
    compositorTileWorkers: new Map(gatherCompositorThreads()),
    entryToNode: new Map(entryToNode2),
    allTraceEntries: [...allTraceEntries]
  };
}
function gatherCompositorThreads() {
  const threadsByProcess = /* @__PURE__ */ new Map();
  for (const worker of compositorTileWorkers) {
    const byProcess = threadsByProcess.get(worker.pid) || [];
    byProcess.push(worker.tid);
    threadsByProcess.set(worker.pid, byProcess);
  }
  return threadsByProcess;
}
function assignMeta(processes2, mainFrameId2, rendererProcessesByFrame, threadsInProcess2) {
  assignOrigin(processes2, rendererProcessesByFrame);
  assignIsMainFrame(processes2, mainFrameId2, rendererProcessesByFrame);
  assignThreadName(processes2, rendererProcessesByFrame, threadsInProcess2);
}
function assignOrigin(processes2, rendererProcessesByFrame) {
  for (const renderProcessesByPid of rendererProcessesByFrame.values()) {
    for (const [pid, processWindows] of renderProcessesByPid) {
      for (const processInfo of processWindows.flat()) {
        const process = getOrCreateRendererProcess(processes2, pid);
        if (process.url === null || process.url === "about:blank") {
          try {
            new URL(processInfo.frame.url);
            process.url = processInfo.frame.url;
          } catch (e) {
            process.url = null;
          }
        }
      }
    }
  }
}
function assignIsMainFrame(processes2, mainFrameId2, rendererProcessesByFrame) {
  for (const [frameId, renderProcessesByPid] of rendererProcessesByFrame) {
    for (const [pid] of renderProcessesByPid) {
      const process = getOrCreateRendererProcess(processes2, pid);
      if (frameId === mainFrameId2) {
        process.isOnMainFrame = true;
      }
    }
  }
}
function assignThreadName(processes2, rendererProcessesByFrame, threadsInProcess2) {
  for (const [, renderProcessesByPid] of rendererProcessesByFrame) {
    for (const [pid] of renderProcessesByPid) {
      const process = getOrCreateRendererProcess(processes2, pid);
      for (const [tid, threadInfo] of threadsInProcess2.get(pid) ?? []) {
        const thread = getOrCreateRendererThread(process, tid);
        thread.name = threadInfo?.args.name ?? `${tid}`;
      }
    }
  }
}
function sanitizeProcesses(processes2) {
  const auctionWorklets = data2().worklets;
  for (const [pid, process] of processes2) {
    if (process.url === null) {
      const maybeWorklet = auctionWorklets.get(pid);
      if (maybeWorklet) {
        process.url = maybeWorklet.host;
      } else {
        processes2.delete(pid);
      }
      continue;
    }
    const asUrl = new URL(process.url);
    if (asUrl.protocol === "about:") {
      processes2.delete(pid);
    }
  }
}
function sanitizeThreads(processes2) {
  for (const [, process] of processes2) {
    for (const [tid, thread] of process.threads) {
      if (!thread.tree?.roots.size) {
        process.threads.delete(tid);
      }
    }
  }
}
function buildHierarchy(processes2, options) {
  for (const [pid, process] of processes2) {
    for (const [tid, thread] of process.threads) {
      if (!thread.entries.length) {
        thread.tree = TreeHelpers_exports.makeEmptyTraceEntryTree();
        continue;
      }
      Trace_exports.sortTraceEventsInPlace(thread.entries);
      const cpuProfile = data5().profilesInProcess.get(pid)?.get(tid)?.parsedProfile;
      const samplesIntegrator = cpuProfile && new SamplesIntegrator_exports.SamplesIntegrator(cpuProfile, pid, tid, config);
      const profileCalls = samplesIntegrator?.buildProfileCalls(thread.entries);
      if (profileCalls) {
        allTraceEntries = [...allTraceEntries, ...profileCalls];
        thread.entries = Trace_exports.mergeEventsInOrder(thread.entries, profileCalls);
      }
      const treeData = TreeHelpers_exports.treify(thread.entries, options);
      thread.tree = treeData.tree;
      for (const [entry, node] of treeData.entryToNode) {
        entryToNode2.set(entry, node);
      }
    }
  }
}
function makeCompleteEvent(event) {
  if (TraceEvents_exports.isTraceEventEnd(event)) {
    const beginEvent = completeEventStack.pop();
    if (!beginEvent) {
      return null;
    }
    if (beginEvent.name !== event.name || beginEvent.cat !== event.cat) {
      console.error("Begin/End events mismatch at " + beginEvent.ts + " (" + beginEvent.name + ") vs. " + event.ts + " (" + event.name + ")");
      return null;
    }
    beginEvent.dur = Timing_exports2.MicroSeconds(event.ts - beginEvent.ts);
    return null;
  }
  const syntheticComplete = {
    ...event,
    ph: TraceEvents_exports.Phase.COMPLETE,
    dur: Timing_exports2.MicroSeconds(0)
  };
  completeEventStack.push(syntheticComplete);
  return syntheticComplete;
}
function deps2() {
  return ["Meta", "Samples", "AuctionWorklets"];
}

// front_end/models/trace/handlers/Threads.ts
var Threads_exports = {};
__export(Threads_exports, {
  ThreadType: () => ThreadType,
  threadsInRenderer: () => threadsInRenderer,
  threadsInTrace: () => threadsInTrace
});
var ThreadType = /* @__PURE__ */ ((ThreadType2) => {
  ThreadType2["MAIN_THREAD"] = "MAIN_THREAD";
  ThreadType2["WORKER"] = "WORKER";
  ThreadType2["RASTERIZER"] = "RASTERIZER";
  ThreadType2["AUCTION_WORKLET"] = "AUCTION_WORKLET";
  ThreadType2["OTHER"] = "OTHER";
  ThreadType2["CPU_PROFILE"] = "CPU_PROFILE";
  return ThreadType2;
})(ThreadType || {});
function getThreadTypeForRendererThread(auctionWorkletsData, pid, thread) {
  let threadType = "OTHER" /* OTHER */;
  if (thread.name === "CrRendererMain") {
    threadType = "MAIN_THREAD" /* MAIN_THREAD */;
  } else if (thread.name === "DedicatedWorker thread") {
    threadType = "WORKER" /* WORKER */;
  } else if (thread.name?.startsWith("CompositorTileWorker")) {
    threadType = "RASTERIZER" /* RASTERIZER */;
  } else if (auctionWorkletsData.worklets.has(pid)) {
    threadType = "AUCTION_WORKLET" /* AUCTION_WORKLET */;
  }
  return threadType;
}
function threadsInRenderer(rendererData, auctionWorkletsData) {
  const foundThreads = [];
  if (rendererData.processes.size) {
    for (const [pid, process] of rendererData.processes) {
      for (const [tid, thread] of process.threads) {
        const threadType = getThreadTypeForRendererThread(auctionWorkletsData, pid, thread);
        if (!thread.tree) {
          continue;
        }
        foundThreads.push({
          name: thread.name,
          pid,
          tid,
          processIsOnMainFrame: process.isOnMainFrame,
          entries: thread.entries,
          tree: thread.tree,
          type: threadType,
          entryToNode: rendererData.entryToNode
        });
      }
    }
  }
  return foundThreads;
}
function threadsInTrace(traceParseData) {
  const threadsFromRenderer = threadsInRenderer(traceParseData.Renderer, traceParseData.AuctionWorklets);
  if (threadsFromRenderer.length) {
    return threadsFromRenderer;
  }
  const foundThreads = [];
  if (traceParseData.Samples.profilesInProcess.size) {
    for (const [pid, process] of traceParseData.Samples.profilesInProcess) {
      for (const [tid, thread] of process) {
        if (!thread.profileTree) {
          continue;
        }
        foundThreads.push({
          pid,
          tid,
          name: null,
          entries: thread.profileCalls,
          processIsOnMainFrame: false,
          tree: thread.profileTree,
          type: "CPU_PROFILE" /* CPU_PROFILE */,
          entryToNode: traceParseData.Samples.entryToNode
        });
      }
    }
  }
  return foundThreads;
}

// front_end/models/trace/handlers/FramesHandler.ts
var handlerState6 = 1 /* UNINITIALIZED */;
var allEvents = [];
var model = null;
function reset7() {
  handlerState6 = 1 /* UNINITIALIZED */;
  allEvents.length = 0;
}
function initialize5() {
  if (handlerState6 !== 1 /* UNINITIALIZED */) {
    throw new Error("FramesHandler was not reset before being initialized");
  }
  handlerState6 = 2 /* INITIALIZED */;
}
function handleEvent7(event) {
  allEvents.push(event);
}
async function finalize7() {
  if (handlerState6 !== 2 /* INITIALIZED */) {
    throw new Error("FramesHandler is not initialized");
  }
  const modelForTrace = new TimelineFrameModel(allEvents, data6(), data2(), data3(), data4());
  model = modelForTrace;
}
function data7() {
  return {
    frames: model ? Array.from(model.frames()) : []
  };
}
function deps3() {
  return ["Meta", "Renderer", "AuctionWorklets", "LayerTree"];
}
function isFrameEvent(event) {
  return TraceEvents_exports.isTraceEventSetLayerId(event) || TraceEvents_exports.isTraceEventBeginFrame(event) || TraceEvents_exports.isTraceEventDroppedFrame(event) || TraceEvents_exports.isTraceEventRequestMainThreadFrame(event) || TraceEvents_exports.isTraceEventBeginMainThreadFrame(event) || TraceEvents_exports.isTraceEventNeedsBeginFrameChanged(event) || TraceEvents_exports.isTraceEventCommit(event) || TraceEvents_exports.isTraceEventCompositeLayers(event) || TraceEvents_exports.isTraceEventActivateLayerTree(event) || TraceEvents_exports.isTraceEventDrawFrame(event);
}
function idForEntry(entry) {
  const scope = TraceEvents_exports.isTraceEventInstant(entry) && entry.s || void 0;
  if (TraceEvents_exports.isNestableAsyncPhase(entry.ph)) {
    const id = Trace_exports.extractId(entry);
    return scope ? `${scope}@${id}` : id;
  }
  return void 0;
}
function entryIsTopLevel(entry) {
  const devtoolsTimelineCategory = "disabled-by-default-devtools.timeline";
  return entry.name === TraceEvents_exports.KnownEventName.RunTask && entry.cat.includes(devtoolsTimelineCategory);
}
var TimelineFrameModel = class {
  #frames = [];
  #frameById = {};
  #beginFrameQueue = new TimelineFrameBeginFrameQueue();
  #minimumRecordTime = Timing_exports2.MicroSeconds(Infinity);
  #lastFrame = null;
  #mainFrameCommitted = false;
  #mainFrameRequested = false;
  #lastLayerTree = null;
  #framePendingActivation = null;
  #framePendingCommit = null;
  #lastBeginFrame = null;
  #lastNeedsBeginFrame = null;
  #lastTaskBeginTime = null;
  #layerTreeId = null;
  #activeProcessId = null;
  #activeThreadId = null;
  #layerTreeData;
  constructor(allEvents3, rendererData, auctionWorkletsData, metaData, layerTreeData) {
    const mainThreads = threadsInRenderer(rendererData, auctionWorkletsData).filter((thread) => {
      return thread.type === "MAIN_THREAD" /* MAIN_THREAD */ && thread.processIsOnMainFrame;
    });
    const threadData = mainThreads.map((thread) => {
      return {
        tid: thread.tid,
        pid: thread.pid,
        startTime: thread.entries[0].ts
      };
    });
    this.#layerTreeData = layerTreeData;
    this.#addTraceEvents(allEvents3, threadData, metaData.mainFrameId);
  }
  frames() {
    return this.#frames;
  }
  #handleBeginFrame(startTime, seqId) {
    if (!this.#lastFrame) {
      this.#startFrame(startTime, seqId);
    }
    this.#lastBeginFrame = startTime;
    this.#beginFrameQueue.addFrameIfNotExists(seqId, startTime, false, false);
  }
  #handleDroppedFrame(startTime, seqId, isPartial) {
    if (!this.#lastFrame) {
      this.#startFrame(startTime, seqId);
    }
    this.#beginFrameQueue.addFrameIfNotExists(seqId, startTime, true, isPartial);
    this.#beginFrameQueue.setDropped(seqId, true);
    this.#beginFrameQueue.setPartial(seqId, isPartial);
  }
  #handleDrawFrame(startTime, seqId) {
    if (!this.#lastFrame) {
      this.#startFrame(startTime, seqId);
      return;
    }
    if (this.#mainFrameCommitted || !this.#mainFrameRequested) {
      if (this.#lastNeedsBeginFrame) {
        const idleTimeEnd = this.#framePendingActivation ? this.#framePendingActivation.triggerTime : this.#lastBeginFrame || this.#lastNeedsBeginFrame;
        if (idleTimeEnd > this.#lastFrame.startTime) {
          this.#lastFrame.idle = true;
          this.#lastBeginFrame = null;
        }
        this.#lastNeedsBeginFrame = null;
      }
      const framesToVisualize = this.#beginFrameQueue.processPendingBeginFramesOnDrawFrame(seqId);
      for (const frame of framesToVisualize) {
        const isLastFrameIdle = this.#lastFrame.idle;
        this.#startFrame(frame.startTime, seqId);
        if (isLastFrameIdle && this.#framePendingActivation) {
          this.#commitPendingFrame();
        }
        if (frame.isDropped) {
          this.#lastFrame.dropped = true;
        }
        if (frame.isPartial) {
          this.#lastFrame.isPartial = true;
        }
      }
    }
    this.#mainFrameCommitted = false;
  }
  #handleActivateLayerTree() {
    if (!this.#lastFrame) {
      return;
    }
    if (this.#framePendingActivation && !this.#lastNeedsBeginFrame) {
      this.#commitPendingFrame();
    }
  }
  #handleRequestMainThreadFrame() {
    if (!this.#lastFrame) {
      return;
    }
    this.#mainFrameRequested = true;
  }
  #handleCommit() {
    if (!this.#framePendingCommit) {
      return;
    }
    this.#framePendingActivation = this.#framePendingCommit;
    this.#framePendingCommit = null;
    this.#mainFrameRequested = false;
    this.#mainFrameCommitted = true;
  }
  #handleLayerTreeSnapshot(layerTree) {
    this.#lastLayerTree = layerTree;
  }
  #handleNeedFrameChanged(startTime, needsBeginFrame) {
    if (needsBeginFrame) {
      this.#lastNeedsBeginFrame = startTime;
    }
  }
  #startFrame(startTime, seqId) {
    if (this.#lastFrame) {
      this.#flushFrame(this.#lastFrame, startTime);
    }
    this.#lastFrame = new TimelineFrame(seqId, startTime, Timing_exports2.MicroSeconds(startTime - this.#minimumRecordTime));
  }
  #flushFrame(frame, endTime) {
    frame.setLayerTree(this.#lastLayerTree);
    frame.setEndTime(endTime);
    if (this.#lastLayerTree) {
      this.#lastLayerTree.paints = frame.paints;
    }
    const lastFrame = this.#frames[this.#frames.length - 1];
    if (this.#frames.length && lastFrame && (frame.startTime !== lastFrame.endTime || frame.startTime > frame.endTime)) {
      console.assert(false, `Inconsistent frame time for frame ${this.#frames.length} (${frame.startTime} - ${frame.endTime})`);
    }
    this.#frames.push(frame);
    if (typeof frame.mainFrameId === "number") {
      this.#frameById[frame.mainFrameId] = frame;
    }
  }
  #commitPendingFrame() {
    if (!this.#framePendingActivation || !this.#lastFrame) {
      return;
    }
    this.#lastFrame.paints = this.#framePendingActivation.paints;
    this.#lastFrame.mainFrameId = this.#framePendingActivation.mainFrameId;
    this.#framePendingActivation = null;
  }
  #addTraceEvents(events2, threadData, mainFrameId2) {
    let j = 0;
    this.#activeThreadId = threadData.length && threadData[0].tid || null;
    this.#activeProcessId = threadData.length && threadData[0].pid || null;
    for (let i = 0; i < events2.length; ++i) {
      while (j + 1 < threadData.length && threadData[j + 1].startTime <= events2[i].ts) {
        this.#activeThreadId = threadData[++j].tid;
        this.#activeProcessId = threadData[j].pid;
      }
      this.#addTraceEvent(events2[i], mainFrameId2);
    }
    this.#activeThreadId = null;
    this.#activeProcessId = null;
  }
  #addTraceEvent(event, mainFrameId2) {
    if (event.ts && event.ts < this.#minimumRecordTime) {
      this.#minimumRecordTime = event.ts;
    }
    const entryId = idForEntry(event);
    if (TraceEvents_exports.isTraceEventSetLayerId(event) && event.args.data.frame === mainFrameId2) {
      this.#layerTreeId = event.args.data.layerTreeId;
    } else if (entryId && TraceEvents_exports.isTraceEventLayerTreeHostImplSnapshot(event) && Number(entryId) === this.#layerTreeId) {
      this.#handleLayerTreeSnapshot({
        entry: event,
        paints: []
      });
    } else {
      if (isFrameEvent(event)) {
        this.#processCompositorEvents(event);
      }
      if (event.tid === this.#activeThreadId && event.pid === this.#activeProcessId) {
        this.#addMainThreadTraceEvent(event);
      }
    }
  }
  #processCompositorEvents(entry) {
    if (entry.args["layerTreeId"] !== this.#layerTreeId) {
      return;
    }
    if (TraceEvents_exports.isTraceEventBeginFrame(entry)) {
      this.#handleBeginFrame(entry.ts, entry.args["frameSeqId"]);
    } else if (TraceEvents_exports.isTraceEventDrawFrame(entry)) {
      this.#handleDrawFrame(entry.ts, entry.args["frameSeqId"]);
    } else if (TraceEvents_exports.isTraceEventActivateLayerTree(entry)) {
      this.#handleActivateLayerTree();
    } else if (TraceEvents_exports.isTraceEventRequestMainThreadFrame(entry)) {
      this.#handleRequestMainThreadFrame();
    } else if (TraceEvents_exports.isTraceEventNeedsBeginFrameChanged(entry)) {
      this.#handleNeedFrameChanged(entry.ts, entry.args["data"] && Boolean(entry.args["data"]["needsBeginFrame"]));
    } else if (TraceEvents_exports.isTraceEventDroppedFrame(entry)) {
      this.#handleDroppedFrame(entry.ts, entry.args["frameSeqId"], Boolean(entry.args["hasPartialUpdate"]));
    }
  }
  #addMainThreadTraceEvent(entry) {
    if (entryIsTopLevel(entry)) {
      this.#lastTaskBeginTime = entry.ts;
    }
    if (!this.#framePendingCommit && MAIN_FRAME_MARKERS.has(entry.name)) {
      this.#framePendingCommit = new PendingFrame(this.#lastTaskBeginTime || entry.ts);
    }
    if (!this.#framePendingCommit) {
      return;
    }
    if (TraceEvents_exports.isTraceEventBeginMainThreadFrame(entry) && entry.args.data.frameId) {
      this.#framePendingCommit.mainFrameId = entry.args.data.frameId;
    }
    if (TraceEvents_exports.isTraceEventPaint(entry)) {
      const snapshot = this.#layerTreeData.paintsToSnapshots.get(entry);
      if (snapshot) {
        this.#framePendingCommit.paints.push(new LayerPaintEvent(entry, snapshot));
      }
    }
    if ((TraceEvents_exports.isTraceEventCompositeLayers(entry) || TraceEvents_exports.isTraceEventCommit(entry)) && entry.args["layerTreeId"] === this.#layerTreeId) {
      this.#handleCommit();
    }
  }
};
var MAIN_FRAME_MARKERS = /* @__PURE__ */ new Set([
  TraceEvents_exports.KnownEventName.ScheduleStyleRecalculation,
  TraceEvents_exports.KnownEventName.InvalidateLayout,
  TraceEvents_exports.KnownEventName.BeginMainThreadFrame,
  TraceEvents_exports.KnownEventName.ScrollLayer
]);
var TimelineFrame = class {
  startTime;
  startTimeOffset;
  endTime;
  duration;
  idle;
  dropped;
  isPartial;
  layerTree;
  paints;
  mainFrameId;
  seqId;
  constructor(seqId, startTime, startTimeOffset) {
    this.seqId = seqId;
    this.startTime = startTime;
    this.startTimeOffset = startTimeOffset;
    this.endTime = this.startTime;
    this.duration = Timing_exports2.MicroSeconds(0);
    this.idle = false;
    this.dropped = false;
    this.isPartial = false;
    this.layerTree = null;
    this.paints = [];
    this.mainFrameId = void 0;
  }
  setEndTime(endTime) {
    this.endTime = endTime;
    this.duration = Timing_exports2.MicroSeconds(this.endTime - this.startTime);
  }
  setLayerTree(layerTree) {
    this.layerTree = layerTree;
  }
};
var LayerPaintEvent = class {
  #event;
  #snapshot;
  constructor(event, snapshot) {
    this.#event = event;
    this.#snapshot = snapshot;
  }
  layerId() {
    return this.#event.args.data.layerId;
  }
  event() {
    return this.#event;
  }
  picture() {
    const rect = this.#snapshot.args.snapshot.params?.layer_rect;
    const pictureData = this.#snapshot.args.snapshot.skp64;
    return rect && pictureData ? { rect, serializedPicture: pictureData } : null;
  }
};
var PendingFrame = class {
  paints;
  mainFrameId;
  triggerTime;
  constructor(triggerTime) {
    this.paints = [];
    this.mainFrameId = void 0;
    this.triggerTime = triggerTime;
  }
};
var BeginFrameInfo = class {
  seqId;
  startTime;
  isDropped;
  isPartial;
  constructor(seqId, startTime, isDropped, isPartial) {
    this.seqId = seqId;
    this.startTime = startTime;
    this.isDropped = isDropped;
    this.isPartial = isPartial;
  }
};
var TimelineFrameBeginFrameQueue = class {
  queueFrames = [];
  mapFrames = {};
  addFrameIfNotExists(seqId, startTime, isDropped, isPartial) {
    if (!(seqId in this.mapFrames)) {
      this.mapFrames[seqId] = new BeginFrameInfo(seqId, startTime, isDropped, isPartial);
      this.queueFrames.push(seqId);
    }
  }
  setDropped(seqId, isDropped) {
    if (seqId in this.mapFrames) {
      this.mapFrames[seqId].isDropped = isDropped;
    }
  }
  setPartial(seqId, isPartial) {
    if (seqId in this.mapFrames) {
      this.mapFrames[seqId].isPartial = isPartial;
    }
  }
  processPendingBeginFramesOnDrawFrame(seqId) {
    const framesToVisualize = [];
    if (seqId in this.mapFrames) {
      while (this.queueFrames[0] !== seqId) {
        const currentSeqId = this.queueFrames[0];
        if (this.mapFrames[currentSeqId].isDropped) {
          framesToVisualize.push(this.mapFrames[currentSeqId]);
        }
        delete this.mapFrames[currentSeqId];
        this.queueFrames.shift();
      }
      framesToVisualize.push(this.mapFrames[seqId]);
      delete this.mapFrames[seqId];
      this.queueFrames.shift();
    }
    return framesToVisualize;
  }
};

// front_end/models/trace/handlers/GPUHandler.ts
var GPUHandler_exports = {};
__export(GPUHandler_exports, {
  data: () => data8,
  deps: () => deps4,
  finalize: () => finalize8,
  handleEvent: () => handleEvent8,
  initialize: () => initialize6,
  reset: () => reset8
});
var handlerState7 = 1 /* UNINITIALIZED */;
var eventsInProcessThread = /* @__PURE__ */ new Map();
var mainGPUThreadTasks = [];
function reset8() {
  eventsInProcessThread.clear();
  mainGPUThreadTasks = [];
  handlerState7 = 1 /* UNINITIALIZED */;
}
function initialize6() {
  if (handlerState7 !== 1 /* UNINITIALIZED */) {
    throw new Error("GPU Handler was not reset before being initialized");
  }
  handlerState7 = 2 /* INITIALIZED */;
}
function handleEvent8(event) {
  if (handlerState7 !== 2 /* INITIALIZED */) {
    throw new Error("GPU Handler is not initialized");
  }
  if (!TraceEvents_exports.isTraceEventGPUTask(event)) {
    return;
  }
  Trace_exports.addEventToProcessThread(event, eventsInProcessThread);
}
async function finalize8() {
  if (handlerState7 !== 2 /* INITIALIZED */) {
    throw new Error("GPU Handler is not initialized");
  }
  const { gpuProcessId: gpuProcessId2, gpuThreadId: gpuThreadId2 } = data3();
  const gpuThreadsForProcess = eventsInProcessThread.get(gpuProcessId2);
  if (gpuThreadsForProcess && gpuThreadId2) {
    mainGPUThreadTasks = gpuThreadsForProcess.get(gpuThreadId2) || [];
  }
  handlerState7 = 3 /* FINALIZED */;
}
function data8() {
  if (handlerState7 !== 3 /* FINALIZED */) {
    throw new Error("GPU Handler is not finalized");
  }
  return {
    mainGPUThreadTasks: [...mainGPUThreadTasks]
  };
}
function deps4() {
  return ["Meta"];
}

// front_end/models/trace/handlers/InitiatorsHandler.ts
var InitiatorsHandler_exports = {};
__export(InitiatorsHandler_exports, {
  data: () => data9,
  finalize: () => finalize9,
  handleEvent: () => handleEvent9,
  initialize: () => initialize7,
  reset: () => reset9
});
var handlerState8 = 1 /* UNINITIALIZED */;
var lastScheduleStyleRecalcByFrame = /* @__PURE__ */ new Map();
var lastInvalidationEventForFrame = /* @__PURE__ */ new Map();
var lastUpdateLayoutTreeByFrame = /* @__PURE__ */ new Map();
var eventToInitiatorMap = /* @__PURE__ */ new Map();
var initiatorToEventsMap = /* @__PURE__ */ new Map();
var requestAnimationFrameEventsById = /* @__PURE__ */ new Map();
var timerInstallEventsById = /* @__PURE__ */ new Map();
var requestIdleCallbackEventsById = /* @__PURE__ */ new Map();
var webSocketCreateEventsById = /* @__PURE__ */ new Map();
function reset9() {
  lastScheduleStyleRecalcByFrame.clear();
  lastInvalidationEventForFrame.clear();
  lastUpdateLayoutTreeByFrame.clear();
  timerInstallEventsById.clear();
  eventToInitiatorMap.clear();
  initiatorToEventsMap.clear();
  requestAnimationFrameEventsById.clear();
  requestIdleCallbackEventsById.clear();
  webSocketCreateEventsById.clear();
  handlerState8 = 1 /* UNINITIALIZED */;
}
function initialize7() {
  if (handlerState8 !== 1 /* UNINITIALIZED */) {
    throw new Error("InitiatorsHandler was not reset before being initialized");
  }
  handlerState8 = 2 /* INITIALIZED */;
}
function storeInitiator(data21) {
  eventToInitiatorMap.set(data21.event, data21.initiator);
  const eventsForInitiator = initiatorToEventsMap.get(data21.initiator) || [];
  eventsForInitiator.push(data21.event);
  initiatorToEventsMap.set(data21.initiator, eventsForInitiator);
}
function handleEvent9(event) {
  if (TraceEvents_exports.isTraceEventScheduleStyleRecalculation(event)) {
    lastScheduleStyleRecalcByFrame.set(event.args.data.frame, event);
  } else if (TraceEvents_exports.isTraceEventUpdateLayoutTree(event)) {
    if (event.args.beginData) {
      lastUpdateLayoutTreeByFrame.set(event.args.beginData.frame, event);
      const scheduledStyleForFrame = lastScheduleStyleRecalcByFrame.get(event.args.beginData.frame);
      if (scheduledStyleForFrame) {
        storeInitiator({
          event,
          initiator: scheduledStyleForFrame
        });
      }
    }
  } else if (TraceEvents_exports.isTraceEventInvalidateLayout(event)) {
    let invalidationInitiator = event;
    if (!lastInvalidationEventForFrame.has(event.args.data.frame)) {
      const lastUpdateLayoutTreeForFrame = lastUpdateLayoutTreeByFrame.get(event.args.data.frame);
      if (lastUpdateLayoutTreeForFrame) {
        const { endTime } = Timing_exports3.eventTimingsMicroSeconds(lastUpdateLayoutTreeForFrame);
        const initiatorOfUpdateLayout = eventToInitiatorMap.get(lastUpdateLayoutTreeForFrame);
        if (initiatorOfUpdateLayout && endTime && endTime > event.ts) {
          invalidationInitiator = initiatorOfUpdateLayout;
        }
      }
    }
    lastInvalidationEventForFrame.set(event.args.data.frame, invalidationInitiator);
  } else if (TraceEvents_exports.isTraceEventLayout(event)) {
    const lastInvalidation = lastInvalidationEventForFrame.get(event.args.beginData.frame);
    if (lastInvalidation) {
      storeInitiator({
        event,
        initiator: lastInvalidation
      });
    }
    lastInvalidationEventForFrame.delete(event.args.beginData.frame);
  } else if (TraceEvents_exports.isTraceEventRequestAnimationFrame(event)) {
    requestAnimationFrameEventsById.set(event.args.data.id, event);
  } else if (TraceEvents_exports.isTraceEventFireAnimationFrame(event)) {
    const matchingRequestEvent = requestAnimationFrameEventsById.get(event.args.data.id);
    if (matchingRequestEvent) {
      storeInitiator({
        event,
        initiator: matchingRequestEvent
      });
    }
  } else if (TraceEvents_exports.isTraceEventTimerInstall(event)) {
    timerInstallEventsById.set(event.args.data.timerId, event);
  } else if (TraceEvents_exports.isTraceEventTimerFire(event)) {
    const matchingInstall = timerInstallEventsById.get(event.args.data.timerId);
    if (matchingInstall) {
      storeInitiator({ event, initiator: matchingInstall });
    }
  } else if (TraceEvents_exports.isTraceEventRequestIdleCallback(event)) {
    requestIdleCallbackEventsById.set(event.args.data.id, event);
  } else if (TraceEvents_exports.isTraceEventFireIdleCallback(event)) {
    const matchingRequestEvent = requestIdleCallbackEventsById.get(event.args.data.id);
    if (matchingRequestEvent) {
      storeInitiator({
        event,
        initiator: matchingRequestEvent
      });
    }
  } else if (TraceEvents_exports.isTraceEventWebSocketCreate(event)) {
    webSocketCreateEventsById.set(event.args.data.identifier, event);
  } else if (TraceEvents_exports.isTraceEventWebSocketSendHandshakeRequest(event)) {
    const matchingCreateEvent = webSocketCreateEventsById.get(event.args.data.identifier);
    if (matchingCreateEvent) {
      storeInitiator({
        event,
        initiator: matchingCreateEvent
      });
    }
  } else if (TraceEvents_exports.isTraceEventWebSocketSendHandshakeRequest(event) || TraceEvents_exports.isTraceEventWebSocketReceiveHandshakeResponse(event) || TraceEvents_exports.isTraceEventWebSocketDestroy(event)) {
    const matchingCreateEvent = webSocketCreateEventsById.get(event.args.data.identifier);
    if (matchingCreateEvent) {
      storeInitiator({
        event,
        initiator: matchingCreateEvent
      });
    }
  }
}
async function finalize9() {
  if (handlerState8 !== 2 /* INITIALIZED */) {
    throw new Error("InitiatorsHandler is not initialized");
  }
  handlerState8 = 3 /* FINALIZED */;
}
function data9() {
  return {
    eventToInitiator: new Map(eventToInitiatorMap),
    initiatorToEvents: new Map(initiatorToEventsMap)
  };
}

// front_end/models/trace/handlers/LargestImagePaintHandler.ts
var LargestImagePaintHandler_exports = {};
__export(LargestImagePaintHandler_exports, {
  data: () => data10,
  handleEvent: () => handleEvent10,
  reset: () => reset10
});
var imageByDOMNodeId = /* @__PURE__ */ new Map();
function reset10() {
  imageByDOMNodeId.clear();
}
function handleEvent10(event) {
  if (!TraceEvents_exports.isTraceEventLargestImagePaintCandidate(event)) {
    return;
  }
  if (!event.args.data) {
    return;
  }
  imageByDOMNodeId.set(event.args.data.DOMNodeId, event);
}
function data10() {
  return new Map(imageByDOMNodeId);
}

// front_end/models/trace/handlers/LargestTextPaintHandler.ts
var LargestTextPaintHandler_exports = {};
__export(LargestTextPaintHandler_exports, {
  data: () => data11,
  handleEvent: () => handleEvent11,
  reset: () => reset11
});
var textPaintByDOMNodeId = /* @__PURE__ */ new Map();
function reset11() {
  textPaintByDOMNodeId.clear();
}
function handleEvent11(event) {
  if (!TraceEvents_exports.isTraceEventLargestTextPaintCandidate(event)) {
    return;
  }
  if (!event.args.data) {
    return;
  }
  textPaintByDOMNodeId.set(event.args.data.DOMNodeId, event);
}
function data11() {
  return new Map(textPaintByDOMNodeId);
}

// front_end/models/trace/handlers/LayoutShiftsHandler.ts
var LayoutShiftsHandler_exports = {};
__export(LayoutShiftsHandler_exports, {
  LayoutShiftsThreshold: () => LayoutShiftsThreshold,
  MAX_CLUSTER_DURATION: () => MAX_CLUSTER_DURATION,
  MAX_SHIFT_TIME_DELTA: () => MAX_SHIFT_TIME_DELTA,
  data: () => data14,
  deps: () => deps7,
  finalize: () => finalize12,
  findNextScreenshotEventIndex: () => findNextScreenshotEventIndex,
  handleEvent: () => handleEvent14,
  initialize: () => initialize8,
  reset: () => reset14,
  stateForLayoutShiftScore: () => stateForLayoutShiftScore
});

// front_end/models/trace/handlers/PageLoadMetricsHandler.ts
var PageLoadMetricsHandler_exports = {};
__export(PageLoadMetricsHandler_exports, {
  MarkerName: () => MarkerName,
  MetricName: () => MetricName,
  ScoreClassification: () => ScoreClassification,
  data: () => data12,
  deps: () => deps5,
  eventIsPageLoadEvent: () => eventIsPageLoadEvent,
  finalize: () => finalize10,
  getFrameIdForPageLoadEvent: () => getFrameIdForPageLoadEvent,
  handleEvent: () => handleEvent12,
  isTraceEventMarkerEvent: () => isTraceEventMarkerEvent,
  reset: () => reset12,
  scoreClassificationForDOMContentLoaded: () => scoreClassificationForDOMContentLoaded,
  scoreClassificationForFirstContentfulPaint: () => scoreClassificationForFirstContentfulPaint,
  scoreClassificationForLargestContentfulPaint: () => scoreClassificationForLargestContentfulPaint,
  scoreClassificationForTimeToInteractive: () => scoreClassificationForTimeToInteractive,
  scoreClassificationForTotalBlockingTime: () => scoreClassificationForTotalBlockingTime
});
var metricScoresByFrameId = /* @__PURE__ */ new Map();
var allMarkerEvents = [];
function reset12() {
  metricScoresByFrameId.clear();
  pageLoadEventsArray = [];
  allMarkerEvents = [];
  selectedLCPCandidateEvents.clear();
}
var pageLoadEventsArray = [];
var selectedLCPCandidateEvents = /* @__PURE__ */ new Set();
var MarkerName = ["MarkDOMContent", "MarkLoad", "firstPaint", "firstContentfulPaint", "largestContentfulPaint::Candidate"];
var markerTypeGuards = [
  TraceEvents_exports.isTraceEventMarkDOMContent,
  TraceEvents_exports.isTraceEventMarkLoad,
  TraceEvents_exports.isTraceEventFirstPaint,
  TraceEvents_exports.isTraceEventFirstContentfulPaint,
  TraceEvents_exports.isTraceEventLargestContentfulPaintCandidate,
  TraceEvents_exports.isTraceEventNavigationStart
];
function isTraceEventMarkerEvent(event) {
  return markerTypeGuards.some((fn) => fn(event));
}
var pageLoadEventTypeGuards = [
  ...markerTypeGuards,
  TraceEvents_exports.isTraceEventInteractiveTime
];
function eventIsPageLoadEvent(event) {
  return pageLoadEventTypeGuards.some((fn) => fn(event));
}
function handleEvent12(event) {
  if (!eventIsPageLoadEvent(event)) {
    return;
  }
  pageLoadEventsArray.push(event);
}
function storePageLoadMetricAgainstNavigationId(navigation, event) {
  const navigationId = navigation.args.data?.navigationId;
  if (!navigationId) {
    throw new Error("Navigation event unexpectedly had no navigation ID.");
  }
  const frameId = getFrameIdForPageLoadEvent(event);
  const { rendererProcessesByFrame } = data3();
  const rendererProcessesInFrame = rendererProcessesByFrame.get(frameId);
  if (!rendererProcessesInFrame) {
    return;
  }
  const processData = rendererProcessesInFrame.get(event.pid);
  if (!processData) {
    return;
  }
  if (TraceEvents_exports.isTraceEventNavigationStart(event)) {
    return;
  }
  if (TraceEvents_exports.isTraceEventFirstContentfulPaint(event)) {
    const fcpTime = Timing_exports2.MicroSeconds(event.ts - navigation.ts);
    const score = Timing_exports3.formatMicrosecondsTime(fcpTime, {
      format: Timing_exports2.TimeUnit.SECONDS,
      maximumFractionDigits: 2
    });
    const classification = scoreClassificationForFirstContentfulPaint(fcpTime);
    const metricScore = { event, score, metricName: MetricName.FCP, classification, navigation };
    storeMetricScore(frameId, navigationId, metricScore);
    return;
  }
  if (TraceEvents_exports.isTraceEventFirstPaint(event)) {
    const paintTime = Timing_exports2.MicroSeconds(event.ts - navigation.ts);
    const score = Timing_exports3.formatMicrosecondsTime(paintTime, {
      format: Timing_exports2.TimeUnit.SECONDS,
      maximumFractionDigits: 2
    });
    const classification = ScoreClassification.UNCLASSIFIED;
    const metricScore = { event, score, metricName: MetricName.FP, classification, navigation };
    storeMetricScore(frameId, navigationId, metricScore);
    return;
  }
  if (TraceEvents_exports.isTraceEventMarkDOMContent(event)) {
    const dclTime = Timing_exports2.MicroSeconds(event.ts - navigation.ts);
    const score = Timing_exports3.formatMicrosecondsTime(dclTime, {
      format: Timing_exports2.TimeUnit.SECONDS,
      maximumFractionDigits: 2
    });
    const metricScore = {
      event,
      score,
      metricName: MetricName.DCL,
      classification: scoreClassificationForDOMContentLoaded(dclTime),
      navigation
    };
    storeMetricScore(frameId, navigationId, metricScore);
    return;
  }
  if (TraceEvents_exports.isTraceEventInteractiveTime(event)) {
    const ttiValue = Timing_exports2.MicroSeconds(event.ts - navigation.ts);
    const ttiScore = Timing_exports3.formatMicrosecondsTime(ttiValue, {
      format: Timing_exports2.TimeUnit.SECONDS,
      maximumFractionDigits: 2
    });
    const tti = {
      event,
      score: ttiScore,
      metricName: MetricName.TTI,
      classification: scoreClassificationForTimeToInteractive(ttiValue),
      navigation
    };
    storeMetricScore(frameId, navigationId, tti);
    const tbtValue = Timing_exports3.millisecondsToMicroseconds(Timing_exports2.MilliSeconds(event.args.args.total_blocking_time_ms));
    const tbtScore = Timing_exports3.formatMicrosecondsTime(tbtValue, {
      format: Timing_exports2.TimeUnit.MILLISECONDS,
      maximumFractionDigits: 2
    });
    const tbt = {
      event,
      score: tbtScore,
      metricName: MetricName.TBT,
      classification: scoreClassificationForTotalBlockingTime(tbtValue),
      navigation
    };
    storeMetricScore(frameId, navigationId, tbt);
    return;
  }
  if (TraceEvents_exports.isTraceEventMarkLoad(event)) {
    const loadTime = Timing_exports2.MicroSeconds(event.ts - navigation.ts);
    const score = Timing_exports3.formatMicrosecondsTime(loadTime, {
      format: Timing_exports2.TimeUnit.SECONDS,
      maximumFractionDigits: 2
    });
    const metricScore = {
      event,
      score,
      metricName: MetricName.L,
      classification: ScoreClassification.UNCLASSIFIED,
      navigation
    };
    storeMetricScore(frameId, navigationId, metricScore);
    return;
  }
  if (TraceEvents_exports.isTraceEventLargestContentfulPaintCandidate(event)) {
    const candidateIndex = event.args.data?.candidateIndex;
    if (!candidateIndex) {
      throw new Error("Largest Contenful Paint unexpectedly had no candidateIndex.");
    }
    const lcpTime = Timing_exports2.MicroSeconds(event.ts - navigation.ts);
    const lcpScore = Timing_exports3.formatMicrosecondsTime(lcpTime, {
      format: Timing_exports2.TimeUnit.SECONDS,
      maximumFractionDigits: 2
    });
    const lcp = {
      event,
      score: lcpScore,
      metricName: MetricName.LCP,
      classification: scoreClassificationForLargestContentfulPaint(lcpTime),
      navigation
    };
    const metricsByNavigation = map_utilities_exports.getWithDefault(metricScoresByFrameId, frameId, () => /* @__PURE__ */ new Map());
    const metrics = map_utilities_exports.getWithDefault(metricsByNavigation, navigationId, () => /* @__PURE__ */ new Map());
    const lastLCPCandidate = metrics.get(MetricName.LCP);
    if (lastLCPCandidate === void 0) {
      selectedLCPCandidateEvents.add(lcp.event);
      storeMetricScore(frameId, navigationId, lcp);
      return;
    }
    const lastLCPCandidateEvent = lastLCPCandidate.event;
    if (!TraceEvents_exports.isTraceEventLargestContentfulPaintCandidate(lastLCPCandidateEvent)) {
      return;
    }
    const lastCandidateIndex = lastLCPCandidateEvent.args.data?.candidateIndex;
    if (!lastCandidateIndex) {
      return;
    }
    if (lastCandidateIndex < candidateIndex) {
      selectedLCPCandidateEvents.delete(lastLCPCandidateEvent);
      selectedLCPCandidateEvents.add(lcp.event);
      storeMetricScore(frameId, navigationId, lcp);
    }
    return;
  }
  if (TraceEvents_exports.isTraceEventLayoutShift(event)) {
    return;
  }
  return assertNever(event, `Unexpected event type: ${event}`);
}
function storeMetricScore(frameId, navigationId, metricScore) {
  const metricsByNavigation = map_utilities_exports.getWithDefault(metricScoresByFrameId, frameId, () => /* @__PURE__ */ new Map());
  const metrics = map_utilities_exports.getWithDefault(metricsByNavigation, navigationId, () => /* @__PURE__ */ new Map());
  metrics.delete(metricScore.metricName);
  metrics.set(metricScore.metricName, metricScore);
}
function getFrameIdForPageLoadEvent(event) {
  if (TraceEvents_exports.isTraceEventFirstContentfulPaint(event) || TraceEvents_exports.isTraceEventInteractiveTime(event) || TraceEvents_exports.isTraceEventLargestContentfulPaintCandidate(event) || TraceEvents_exports.isTraceEventNavigationStart(event) || TraceEvents_exports.isTraceEventLayoutShift(event) || TraceEvents_exports.isTraceEventFirstPaint(event)) {
    return event.args.frame;
  }
  if (TraceEvents_exports.isTraceEventMarkDOMContent(event) || TraceEvents_exports.isTraceEventMarkLoad(event)) {
    const frameId = event.args.data?.frame;
    if (!frameId) {
      throw new Error("MarkDOMContent unexpectedly had no frame ID.");
    }
    return frameId;
  }
  assertNever(event, `Unexpected event type: ${event}`);
}
function getNavigationForPageLoadEvent(event) {
  if (TraceEvents_exports.isTraceEventFirstContentfulPaint(event) || TraceEvents_exports.isTraceEventLargestContentfulPaintCandidate(event) || TraceEvents_exports.isTraceEventFirstPaint(event)) {
    const navigationId = event.args.data?.navigationId;
    if (!navigationId) {
      throw new Error("Trace event unexpectedly had no navigation ID.");
    }
    const { navigationsByNavigationId: navigationsByNavigationId2 } = data3();
    const navigation = navigationsByNavigationId2.get(navigationId);
    if (!navigation) {
      return null;
    }
    return navigation;
  }
  if (TraceEvents_exports.isTraceEventMarkDOMContent(event) || TraceEvents_exports.isTraceEventInteractiveTime(event) || TraceEvents_exports.isTraceEventLayoutShift(event) || TraceEvents_exports.isTraceEventMarkLoad(event)) {
    const frameId = getFrameIdForPageLoadEvent(event);
    const { navigationsByFrameId: navigationsByFrameId2 } = data3();
    return Trace_exports.getNavigationForTraceEvent(event, frameId, navigationsByFrameId2);
  }
  if (TraceEvents_exports.isTraceEventNavigationStart(event)) {
    return null;
  }
  return assertNever(event, `Unexpected event type: ${event}`);
}
function scoreClassificationForFirstContentfulPaint(fcpScoreInMicroseconds) {
  const FCP_GOOD_TIMING = Timing_exports3.secondsToMicroseconds(Timing_exports2.Seconds(1.8));
  const FCP_MEDIUM_TIMING = Timing_exports3.secondsToMicroseconds(Timing_exports2.Seconds(3));
  let scoreClassification = ScoreClassification.BAD;
  if (fcpScoreInMicroseconds <= FCP_MEDIUM_TIMING) {
    scoreClassification = ScoreClassification.OK;
  }
  if (fcpScoreInMicroseconds <= FCP_GOOD_TIMING) {
    scoreClassification = ScoreClassification.GOOD;
  }
  return scoreClassification;
}
function scoreClassificationForTimeToInteractive(ttiTimeInMicroseconds) {
  const TTI_GOOD_TIMING = Timing_exports3.secondsToMicroseconds(Timing_exports2.Seconds(3.8));
  const TTI_MEDIUM_TIMING = Timing_exports3.secondsToMicroseconds(Timing_exports2.Seconds(7.3));
  let scoreClassification = ScoreClassification.BAD;
  if (ttiTimeInMicroseconds <= TTI_MEDIUM_TIMING) {
    scoreClassification = ScoreClassification.OK;
  }
  if (ttiTimeInMicroseconds <= TTI_GOOD_TIMING) {
    scoreClassification = ScoreClassification.GOOD;
  }
  return scoreClassification;
}
function scoreClassificationForLargestContentfulPaint(lcpTimeInMicroseconds) {
  const LCP_GOOD_TIMING = Timing_exports3.secondsToMicroseconds(Timing_exports2.Seconds(2.5));
  const LCP_MEDIUM_TIMING = Timing_exports3.secondsToMicroseconds(Timing_exports2.Seconds(4));
  let scoreClassification = ScoreClassification.BAD;
  if (lcpTimeInMicroseconds <= LCP_MEDIUM_TIMING) {
    scoreClassification = ScoreClassification.OK;
  }
  if (lcpTimeInMicroseconds <= LCP_GOOD_TIMING) {
    scoreClassification = ScoreClassification.GOOD;
  }
  return scoreClassification;
}
function scoreClassificationForDOMContentLoaded(_dclTimeInMicroseconds) {
  return ScoreClassification.UNCLASSIFIED;
}
function scoreClassificationForTotalBlockingTime(tbtTimeInMicroseconds) {
  const TBT_GOOD_TIMING = Timing_exports3.millisecondsToMicroseconds(Timing_exports2.MilliSeconds(200));
  const TBT_MEDIUM_TIMING = Timing_exports3.millisecondsToMicroseconds(Timing_exports2.MilliSeconds(600));
  let scoreClassification = ScoreClassification.BAD;
  if (tbtTimeInMicroseconds <= TBT_MEDIUM_TIMING) {
    scoreClassification = ScoreClassification.OK;
  }
  if (tbtTimeInMicroseconds <= TBT_GOOD_TIMING) {
    scoreClassification = ScoreClassification.GOOD;
  }
  return scoreClassification;
}
function gatherFinalLCPEvents() {
  const allFinalLCPEvents = [];
  const dataForAllFrames = [...metricScoresByFrameId.values()];
  const dataForAllNavigations = dataForAllFrames.flatMap((frameData) => [...frameData.values()]);
  for (let i = 0; i < dataForAllNavigations.length; i++) {
    const navigationData = dataForAllNavigations[i];
    const lcpInNavigation = navigationData.get(MetricName.LCP);
    if (!lcpInNavigation || !lcpInNavigation.event) {
      continue;
    }
    allFinalLCPEvents.push(lcpInNavigation.event);
  }
  return allFinalLCPEvents;
}
async function finalize10() {
  pageLoadEventsArray.sort((a, b) => a.ts - b.ts);
  for (const pageLoadEvent of pageLoadEventsArray) {
    const navigation = getNavigationForPageLoadEvent(pageLoadEvent);
    if (navigation) {
      storePageLoadMetricAgainstNavigationId(navigation, pageLoadEvent);
    }
  }
  const allFinalLCPEvents = gatherFinalLCPEvents();
  const mainFrame = data3().mainFrameId;
  const allEventsButLCP = pageLoadEventsArray.filter((event) => !TraceEvents_exports.isTraceEventLargestContentfulPaintCandidate(event));
  const markerEvents = [...allFinalLCPEvents, ...allEventsButLCP].filter(isTraceEventMarkerEvent);
  allMarkerEvents = markerEvents.filter((event) => getFrameIdForPageLoadEvent(event) === mainFrame).sort((a, b) => a.ts - b.ts);
}
function data12() {
  return {
    metricScoresByFrameId: new Map(metricScoresByFrameId),
    allMarkerEvents: [...allMarkerEvents]
  };
}
function deps5() {
  return ["Meta"];
}
var ScoreClassification = /* @__PURE__ */ ((ScoreClassification2) => {
  ScoreClassification2["GOOD"] = "good";
  ScoreClassification2["OK"] = "ok";
  ScoreClassification2["BAD"] = "bad";
  ScoreClassification2["UNCLASSIFIED"] = "unclassified";
  return ScoreClassification2;
})(ScoreClassification || {});
var MetricName = /* @__PURE__ */ ((MetricName2) => {
  MetricName2["FCP"] = "FCP";
  MetricName2["FP"] = "FP";
  MetricName2["L"] = "L";
  MetricName2["LCP"] = "LCP";
  MetricName2["DCL"] = "DCL";
  MetricName2["TTI"] = "TTI";
  MetricName2["TBT"] = "TBT";
  MetricName2["CLS"] = "CLS";
  return MetricName2;
})(MetricName || {});

// front_end/models/trace/handlers/ScreenshotsHandler.ts
var ScreenshotsHandler_exports = {};
__export(ScreenshotsHandler_exports, {
  data: () => data13,
  deps: () => deps6,
  finalize: () => finalize11,
  handleEvent: () => handleEvent13,
  reset: () => reset13
});
var eventsInProcessThread2 = /* @__PURE__ */ new Map();
var snapshots = [];
function reset13() {
  eventsInProcessThread2.clear();
  snapshots.length = 0;
}
function handleEvent13(event) {
  if (event.name !== "Screenshot") {
    return;
  }
  Trace_exports.addEventToProcessThread(event, eventsInProcessThread2);
}
async function finalize11() {
  const { browserProcessId: browserProcessId2, browserThreadId: browserThreadId2 } = data3();
  const browserThreads = eventsInProcessThread2.get(browserProcessId2);
  if (browserThreads) {
    snapshots = browserThreads.get(browserThreadId2) || [];
  }
}
function data13() {
  return [...snapshots];
}
function deps6() {
  return ["Meta"];
}

// front_end/models/trace/handlers/LayoutShiftsHandler.ts
var MAX_CLUSTER_DURATION = Timing_exports3.millisecondsToMicroseconds(Timing_exports2.MilliSeconds(5e3));
var MAX_SHIFT_TIME_DELTA = Timing_exports3.millisecondsToMicroseconds(Timing_exports2.MilliSeconds(1e3));
var layoutShiftEvents = [];
var layoutInvalidationEvents = [];
var styleRecalcInvalidationEvents = [];
var backendNodeIds = /* @__PURE__ */ new Set();
var prePaintEvents = [];
var sessionMaxScore = 0;
var clsWindowID = -1;
var clusters = [];
var scoreRecords = [];
var handlerState9 = 1 /* UNINITIALIZED */;
function initialize8() {
  if (handlerState9 !== 1 /* UNINITIALIZED */) {
    throw new Error("LayoutShifts Handler was not reset");
  }
  handlerState9 = 2 /* INITIALIZED */;
}
function reset14() {
  handlerState9 = 1 /* UNINITIALIZED */;
  layoutShiftEvents.length = 0;
  layoutInvalidationEvents.length = 0;
  prePaintEvents.length = 0;
  backendNodeIds.clear();
  clusters.length = 0;
  sessionMaxScore = 0;
  scoreRecords.length = 0;
  clsWindowID = -1;
}
function handleEvent14(event) {
  if (handlerState9 !== 2 /* INITIALIZED */) {
    throw new Error("Handler is not initialized");
  }
  if (TraceEvents_exports.isTraceEventLayoutShift(event) && !event.args.data?.had_recent_input) {
    layoutShiftEvents.push(event);
    return;
  }
  if (TraceEvents_exports.isTraceEventLayoutInvalidation(event)) {
    layoutInvalidationEvents.push(event);
    return;
  }
  if (TraceEvents_exports.isTraceEventStyleRecalcInvalidation(event)) {
    styleRecalcInvalidationEvents.push(event);
  }
  if (TraceEvents_exports.isTraceEventPrePaint(event)) {
    prePaintEvents.push(event);
    return;
  }
}
function traceWindowFromTime(time) {
  return {
    min: time,
    max: time,
    range: Timing_exports2.MicroSeconds(0)
  };
}
function updateTraceWindowMax(traceWindow, newMax) {
  traceWindow.max = newMax;
  traceWindow.range = Timing_exports2.MicroSeconds(traceWindow.max - traceWindow.min);
}
function findNextScreenshotSource(timestamp) {
  const screenshots = data13();
  const screenshotIndex = findNextScreenshotEventIndex(screenshots, timestamp);
  if (!screenshotIndex) {
    return void 0;
  }
  return `data:img/png;base64,${screenshots[screenshotIndex].args.snapshot}`;
}
function findNextScreenshotEventIndex(screenshots, timestamp) {
  return array_utilities_exports.nearestIndexFromBeginning(screenshots, (frame) => frame.ts > timestamp);
}
function buildScoreRecords() {
  const { traceBounds: traceBounds2 } = data3();
  scoreRecords.push({ ts: traceBounds2.min, score: 0 });
  for (const cluster of clusters) {
    let clusterScore = 0;
    if (cluster.events[0].args.data) {
      scoreRecords.push({ ts: cluster.clusterWindow.min, score: cluster.events[0].args.data.weighted_score_delta });
    }
    for (let i = 0; i < cluster.events.length; i++) {
      const event = cluster.events[i];
      if (!event.args.data) {
        continue;
      }
      clusterScore += event.args.data.weighted_score_delta;
      scoreRecords.push({ ts: event.ts, score: clusterScore });
    }
    scoreRecords.push({ ts: cluster.clusterWindow.max, score: 0 });
  }
}
function collectNodes() {
  backendNodeIds.clear();
  for (const layoutShift of layoutShiftEvents) {
    if (!layoutShift.args.data?.impacted_nodes) {
      continue;
    }
    for (const node of layoutShift.args.data.impacted_nodes) {
      backendNodeIds.add(node.node_id);
    }
  }
  for (const layoutInvalidation of layoutInvalidationEvents) {
    if (!layoutInvalidation.args.data?.nodeId) {
      continue;
    }
    backendNodeIds.add(layoutInvalidation.args.data.nodeId);
  }
}
async function finalize12() {
  layoutShiftEvents.sort((a, b) => a.ts - b.ts);
  prePaintEvents.sort((a, b) => a.ts - b.ts);
  layoutInvalidationEvents.sort((a, b) => a.ts - b.ts);
  await buildLayoutShiftsClusters();
  buildScoreRecords();
  collectNodes();
  handlerState9 = 3 /* FINALIZED */;
}
async function buildLayoutShiftsClusters() {
  const { navigationsByFrameId: navigationsByFrameId2, mainFrameId: mainFrameId2, traceBounds: traceBounds2 } = data3();
  const navigations = navigationsByFrameId2.get(mainFrameId2) || [];
  if (layoutShiftEvents.length === 0) {
    return;
  }
  let firstShiftTime = layoutShiftEvents[0].ts;
  let lastShiftTime = layoutShiftEvents[0].ts;
  let lastShiftNavigation = null;
  for (const event of layoutShiftEvents) {
    const clusterDurationExceeded = event.ts - firstShiftTime > MAX_CLUSTER_DURATION;
    const maxTimeDeltaSinceLastShiftExceeded = event.ts - lastShiftTime > MAX_SHIFT_TIME_DELTA;
    const currentShiftNavigation = array_utilities_exports.nearestIndexFromEnd(navigations, (nav) => nav.ts < event.ts);
    const hasNavigated = lastShiftNavigation !== currentShiftNavigation && currentShiftNavigation !== null;
    if (clusterDurationExceeded || maxTimeDeltaSinceLastShiftExceeded || hasNavigated || !clusters.length) {
      const clusterStartTime = event.ts;
      const endTimeByMaxSessionDuration = clusterDurationExceeded ? firstShiftTime + MAX_CLUSTER_DURATION : Infinity;
      const endTimeByMaxShiftGap = maxTimeDeltaSinceLastShiftExceeded ? lastShiftTime + MAX_SHIFT_TIME_DELTA : Infinity;
      const endTimeByNavigation = hasNavigated ? navigations[currentShiftNavigation].ts : Infinity;
      const previousClusterEndTime = Math.min(endTimeByMaxSessionDuration, endTimeByMaxShiftGap, endTimeByNavigation);
      if (clusters.length > 0) {
        const currentCluster2 = clusters[clusters.length - 1];
        updateTraceWindowMax(currentCluster2.clusterWindow, Timing_exports2.MicroSeconds(previousClusterEndTime));
      }
      clusters.push({
        events: [],
        clusterWindow: traceWindowFromTime(clusterStartTime),
        clusterCumulativeScore: 0,
        scoreWindows: {
          good: traceWindowFromTime(clusterStartTime),
          needsImprovement: null,
          bad: null
        }
      });
      firstShiftTime = clusterStartTime;
    }
    const currentCluster = clusters[clusters.length - 1];
    const timeFromNavigation = currentShiftNavigation !== null ? Timing_exports2.MicroSeconds(event.ts - navigations[currentShiftNavigation].ts) : void 0;
    currentCluster.clusterCumulativeScore += event.args.data ? event.args.data.weighted_score_delta : 0;
    if (!event.args.data) {
      continue;
    }
    const shift = {
      ...event,
      args: {
        frame: event.args.frame,
        data: {
          ...event.args.data,
          rawEvent: event
        }
      },
      parsedData: {
        screenshotSource: findNextScreenshotSource(event.ts),
        timeFromNavigation,
        cumulativeWeightedScoreInWindow: currentCluster.clusterCumulativeScore,
        sessionWindowData: { cumulativeWindowScore: 0, id: clusters.length }
      }
    };
    currentCluster.events.push(shift);
    updateTraceWindowMax(currentCluster.clusterWindow, event.ts);
    lastShiftTime = event.ts;
    lastShiftNavigation = currentShiftNavigation;
  }
  for (const cluster of clusters) {
    let weightedScore = 0;
    let windowID = -1;
    if (cluster === clusters[clusters.length - 1]) {
      const clusterEndByMaxDuration = MAX_CLUSTER_DURATION + cluster.clusterWindow.min;
      const clusterEndByMaxGap = cluster.clusterWindow.max + MAX_SHIFT_TIME_DELTA;
      const nextNavigationIndex = array_utilities_exports.nearestIndexFromBeginning(navigations, (nav) => nav.ts > cluster.clusterWindow.max);
      const nextNavigationTime = nextNavigationIndex ? navigations[nextNavigationIndex].ts : Infinity;
      const clusterEnd = Math.min(clusterEndByMaxDuration, clusterEndByMaxGap, traceBounds2.max, nextNavigationTime);
      updateTraceWindowMax(cluster.clusterWindow, Timing_exports2.MicroSeconds(clusterEnd));
    }
    for (const shift of cluster.events) {
      weightedScore += shift.args.data ? shift.args.data.weighted_score_delta : 0;
      windowID = shift.parsedData.sessionWindowData.id;
      const ts = shift.ts;
      shift.parsedData.sessionWindowData.cumulativeWindowScore = cluster.clusterCumulativeScore;
      if (weightedScore < LayoutShiftsThreshold.NEEDS_IMPROVEMENT) {
        updateTraceWindowMax(cluster.scoreWindows.good, ts);
      } else if (weightedScore >= LayoutShiftsThreshold.NEEDS_IMPROVEMENT && weightedScore < LayoutShiftsThreshold.BAD) {
        if (!cluster.scoreWindows.needsImprovement) {
          updateTraceWindowMax(cluster.scoreWindows.good, Timing_exports2.MicroSeconds(ts - 1));
          cluster.scoreWindows.needsImprovement = traceWindowFromTime(ts);
        }
        updateTraceWindowMax(cluster.scoreWindows.needsImprovement, ts);
      } else if (weightedScore >= LayoutShiftsThreshold.BAD) {
        if (!cluster.scoreWindows.bad) {
          if (cluster.scoreWindows.needsImprovement) {
            updateTraceWindowMax(cluster.scoreWindows.needsImprovement, Timing_exports2.MicroSeconds(ts - 1));
          } else {
            updateTraceWindowMax(cluster.scoreWindows.good, Timing_exports2.MicroSeconds(ts - 1));
          }
          cluster.scoreWindows.bad = traceWindowFromTime(shift.ts);
        }
        updateTraceWindowMax(cluster.scoreWindows.bad, ts);
      }
      if (cluster.scoreWindows.bad) {
        updateTraceWindowMax(cluster.scoreWindows.bad, cluster.clusterWindow.max);
      } else if (cluster.scoreWindows.needsImprovement) {
        updateTraceWindowMax(cluster.scoreWindows.needsImprovement, cluster.clusterWindow.max);
      } else {
        updateTraceWindowMax(cluster.scoreWindows.good, cluster.clusterWindow.max);
      }
    }
    if (weightedScore > sessionMaxScore) {
      clsWindowID = windowID;
      sessionMaxScore = weightedScore;
    }
  }
}
function data14() {
  if (handlerState9 !== 3 /* FINALIZED */) {
    throw new Error("Layout Shifts Handler is not finalized");
  }
  return {
    clusters: [...clusters],
    sessionMaxScore,
    clsWindowID,
    prePaintEvents: [...prePaintEvents],
    layoutInvalidationEvents: [...layoutInvalidationEvents],
    styleRecalcInvalidationEvents: [],
    scoreRecords: [...scoreRecords],
    backendNodeIds: [...backendNodeIds]
  };
}
function deps7() {
  return ["Screenshots", "Meta"];
}
function stateForLayoutShiftScore(score) {
  let state = "good" /* GOOD */;
  if (score >= LayoutShiftsThreshold.NEEDS_IMPROVEMENT) {
    state = "ok" /* OK */;
  }
  if (score >= LayoutShiftsThreshold.BAD) {
    state = "bad" /* BAD */;
  }
  return state;
}
var LayoutShiftsThreshold = /* @__PURE__ */ ((LayoutShiftsThreshold2) => {
  LayoutShiftsThreshold2[LayoutShiftsThreshold2["GOOD"] = 0] = "GOOD";
  LayoutShiftsThreshold2[LayoutShiftsThreshold2["NEEDS_IMPROVEMENT"] = 0.1] = "NEEDS_IMPROVEMENT";
  LayoutShiftsThreshold2[LayoutShiftsThreshold2["BAD"] = 0.25] = "BAD";
  return LayoutShiftsThreshold2;
})(LayoutShiftsThreshold || {});

// front_end/models/trace/handlers/MemoryHandler.ts
var MemoryHandler_exports = {};
__export(MemoryHandler_exports, {
  data: () => data15,
  handleEvent: () => handleEvent15,
  reset: () => reset15
});
var updateCountersByProcess = /* @__PURE__ */ new Map();
function reset15() {
  updateCountersByProcess.clear();
}
function handleEvent15(event) {
  if (TraceEvents_exports.isTraceEventUpdateCounters(event)) {
    const countersForProcess = map_utilities_exports.getWithDefault(updateCountersByProcess, event.pid, () => []);
    countersForProcess.push(event);
    updateCountersByProcess.set(event.pid, countersForProcess);
  }
}
function data15() {
  return { updateCountersByProcess: new Map(updateCountersByProcess) };
}

// front_end/models/trace/handlers/NetworkRequestsHandler.ts
var NetworkRequestsHandler_exports = {};
__export(NetworkRequestsHandler_exports, {
  data: () => data16,
  deps: () => deps8,
  finalize: () => finalize13,
  handleEvent: () => handleEvent16,
  initialize: () => initialize9,
  reset: () => reset16
});
var MILLISECONDS_TO_MICROSECONDS = 1e3;
var SECONDS_TO_MICROSECONDS = 1e6;
var requestMap = /* @__PURE__ */ new Map();
var requestsByOrigin = /* @__PURE__ */ new Map();
var requestsByTime = [];
function storeTraceEventWithRequestId(requestId, key, value) {
  if (!requestMap.has(requestId)) {
    requestMap.set(requestId, {});
  }
  const traceEvents = requestMap.get(requestId);
  if (!traceEvents) {
    throw new Error(`Unable to locate trace events for request ID ${requestId}`);
  }
  if (Array.isArray(traceEvents[key])) {
    const target = traceEvents[key];
    const values = value;
    target.push(...values);
  } else {
    traceEvents[key] = value;
  }
}
function firstPositiveValueInList(entries) {
  for (const entry of entries) {
    if (entry > 0) {
      return entry;
    }
  }
  return 0;
}
var handlerState10 = 1 /* UNINITIALIZED */;
function reset16() {
  requestsByOrigin.clear();
  requestMap.clear();
  requestsByTime.length = 0;
  handlerState10 = 1 /* UNINITIALIZED */;
}
function initialize9() {
  handlerState10 = 2 /* INITIALIZED */;
}
function handleEvent16(event) {
  if (handlerState10 !== 2 /* INITIALIZED */) {
    throw new Error("Network Request handler is not initialized");
  }
  if (TraceEvents_exports.isTraceEventResourceChangePriority(event)) {
    storeTraceEventWithRequestId(event.args.data.requestId, "changePriority", event);
    return;
  }
  if (TraceEvents_exports.isTraceEventResourceWillSendRequest(event)) {
    storeTraceEventWithRequestId(event.args.data.requestId, "willSendRequests", [event]);
    return;
  }
  if (TraceEvents_exports.isTraceEventResourceSendRequest(event)) {
    storeTraceEventWithRequestId(event.args.data.requestId, "sendRequests", [event]);
    return;
  }
  if (TraceEvents_exports.isTraceEventResourceReceiveResponse(event)) {
    storeTraceEventWithRequestId(event.args.data.requestId, "receiveResponse", event);
    return;
  }
  if (TraceEvents_exports.isTraceEventResourceReceivedData(event)) {
    storeTraceEventWithRequestId(event.args.data.requestId, "receivedData", [event]);
    return;
  }
  if (TraceEvents_exports.isTraceEventResourceFinish(event)) {
    storeTraceEventWithRequestId(event.args.data.requestId, "resourceFinish", event);
    return;
  }
  if (TraceEvents_exports.isTraceEventResourceMarkAsCached(event)) {
    storeTraceEventWithRequestId(event.args.data.requestId, "resourceMarkAsCached", event);
    return;
  }
}
async function finalize13() {
  if (handlerState10 !== 2 /* INITIALIZED */) {
    throw new Error("Network Request handler is not initialized");
  }
  const { rendererProcessesByFrame } = data3();
  for (const [requestId, request] of requestMap.entries()) {
    if (!request.sendRequests || !request.receiveResponse) {
      continue;
    }
    const redirects = [];
    for (let i = 0; i < request.sendRequests.length - 1; i++) {
      const sendRequest = request.sendRequests[i];
      const nextSendRequest = request.sendRequests[i + 1];
      let ts = sendRequest.ts;
      let dur = Timing_exports2.MicroSeconds(nextSendRequest.ts - sendRequest.ts);
      if (request.willSendRequests && request.willSendRequests[i] && request.willSendRequests[i + 1]) {
        const willSendRequest = request.willSendRequests[i];
        const nextWillSendRequest = request.willSendRequests[i + 1];
        ts = willSendRequest.ts;
        dur = Timing_exports2.MicroSeconds(nextWillSendRequest.ts - willSendRequest.ts);
      }
      redirects.push({
        url: sendRequest.args.data.url,
        priority: sendRequest.args.data.priority,
        requestMethod: sendRequest.args.data.requestMethod,
        ts,
        dur
      });
    }
    const isPushedResource = request.resourceFinish?.args.data.encodedDataLength !== 0;
    const isDiskCached = request.receiveResponse.args.data.fromCache && !request.receiveResponse.args.data.fromServiceWorker && !isPushedResource;
    const isMemoryCached = request.resourceMarkAsCached !== void 0;
    const isCached = isMemoryCached || isDiskCached;
    const timing = request.receiveResponse.args.data.timing;
    if (!timing && !isCached) {
      continue;
    }
    const firstSendRequest = request.sendRequests[0];
    const finalSendRequest = request.sendRequests[request.sendRequests.length - 1];
    const initialPriority = finalSendRequest.args.data.priority;
    let finalPriority = initialPriority;
    if (request.changePriority) {
      finalPriority = request.changePriority.args.data.priority;
    }
    const startTime = request.willSendRequests && request.willSendRequests.length ? Timing_exports2.MicroSeconds(request.willSendRequests[0].ts) : Timing_exports2.MicroSeconds(firstSendRequest.ts);
    const endRedirectTime = request.willSendRequests && request.willSendRequests.length ? Timing_exports2.MicroSeconds(request.willSendRequests[request.willSendRequests.length - 1].ts) : Timing_exports2.MicroSeconds(finalSendRequest.ts);
    const endTime = request.resourceFinish ? request.resourceFinish.ts : endRedirectTime;
    const finishTime = request.resourceFinish?.args.data.finishTime ? Timing_exports2.MicroSeconds(request.resourceFinish.args.data.finishTime * SECONDS_TO_MICROSECONDS) : Timing_exports2.MicroSeconds(endTime);
    const networkDuration = isCached ? Timing_exports2.MicroSeconds(0) : Timing_exports2.MicroSeconds((finishTime || endRedirectTime) - endRedirectTime);
    const processingDuration = Timing_exports2.MicroSeconds(endTime - (finishTime || endTime));
    const redirectionDuration = Timing_exports2.MicroSeconds(endRedirectTime - startTime);
    const queueing = isCached ? Timing_exports2.MicroSeconds(0) : Timing_exports2.MicroSeconds(number_utilities_exports.clamp(timing.requestTime * SECONDS_TO_MICROSECONDS - endRedirectTime, 0, Number.MAX_VALUE));
    const stalled = isCached ? Timing_exports2.MicroSeconds(request.receiveResponse.ts - startTime) : Timing_exports2.MicroSeconds(firstPositiveValueInList([
      timing.dnsStart * MILLISECONDS_TO_MICROSECONDS,
      timing.connectStart * MILLISECONDS_TO_MICROSECONDS,
      timing.sendStart * MILLISECONDS_TO_MICROSECONDS,
      request.receiveResponse.ts - endRedirectTime
    ]));
    const sendStartTime = isCached ? startTime : Timing_exports2.MicroSeconds(timing.requestTime * SECONDS_TO_MICROSECONDS + timing.sendStart * MILLISECONDS_TO_MICROSECONDS);
    const waiting = isCached ? Timing_exports2.MicroSeconds(0) : Timing_exports2.MicroSeconds((timing.receiveHeadersEnd - timing.sendEnd) * MILLISECONDS_TO_MICROSECONDS);
    const downloadStart = isCached ? startTime : Timing_exports2.MicroSeconds(timing.requestTime * SECONDS_TO_MICROSECONDS + timing.receiveHeadersEnd * MILLISECONDS_TO_MICROSECONDS);
    const download = isCached ? Timing_exports2.MicroSeconds(endTime - request.receiveResponse.ts) : Timing_exports2.MicroSeconds((finishTime || downloadStart) - downloadStart);
    const totalTime = Timing_exports2.MicroSeconds(networkDuration + processingDuration);
    const dnsLookup = isCached ? Timing_exports2.MicroSeconds(0) : Timing_exports2.MicroSeconds((timing.dnsEnd - timing.dnsStart) * MILLISECONDS_TO_MICROSECONDS);
    const ssl = isCached ? Timing_exports2.MicroSeconds(0) : Timing_exports2.MicroSeconds((timing.sslEnd - timing.sslStart) * MILLISECONDS_TO_MICROSECONDS);
    const proxyNegotiation = isCached ? Timing_exports2.MicroSeconds(0) : Timing_exports2.MicroSeconds((timing.proxyEnd - timing.proxyStart) * MILLISECONDS_TO_MICROSECONDS);
    const requestSent = isCached ? Timing_exports2.MicroSeconds(0) : Timing_exports2.MicroSeconds((timing.sendEnd - timing.sendStart) * MILLISECONDS_TO_MICROSECONDS);
    const initialConnection = isCached ? Timing_exports2.MicroSeconds(0) : Timing_exports2.MicroSeconds((timing.connectEnd - timing.connectStart) * MILLISECONDS_TO_MICROSECONDS);
    const { frame, url, renderBlocking } = finalSendRequest.args.data;
    const { encodedDataLength, decodedBodyLength } = request.resourceFinish ? request.resourceFinish.args.data : { encodedDataLength: 0, decodedBodyLength: 0 };
    const { host, protocol, pathname, search } = new URL(url);
    const isHttps = protocol === "https:";
    const requestingFrameUrl = Trace_exports.activeURLForFrameAtTime(frame, finalSendRequest.ts, rendererProcessesByFrame) || "";
    const networkEvent = {
      args: {
        data: {
          syntheticData: {
            dnsLookup,
            download,
            downloadStart,
            finishTime,
            initialConnection,
            isDiskCached,
            isHttps,
            isMemoryCached,
            isPushedResource,
            networkDuration,
            processingDuration,
            proxyNegotiation,
            queueing,
            redirectionDuration,
            requestSent,
            sendStartTime,
            ssl,
            stalled,
            totalTime,
            waiting
          },
          decodedBodyLength,
          encodedDataLength,
          frame,
          fromServiceWorker: request.receiveResponse.args.data.fromServiceWorker,
          host,
          mimeType: request.receiveResponse.args.data.mimeType,
          pathname,
          priority: finalPriority,
          initialPriority,
          protocol,
          redirects,
          renderBlocking: renderBlocking ? renderBlocking : "non_blocking",
          requestId,
          requestingFrameUrl,
          requestMethod: finalSendRequest.args.data.requestMethod,
          search,
          statusCode: request.receiveResponse.args.data.statusCode,
          stackTrace: finalSendRequest.args.data.stackTrace,
          timing,
          url
        }
      },
      cat: "loading",
      name: "SyntheticNetworkRequest",
      ph: TraceEvents_exports.Phase.COMPLETE,
      dur: Timing_exports2.MicroSeconds(endTime - startTime),
      tdur: Timing_exports2.MicroSeconds(endTime - startTime),
      ts: Timing_exports2.MicroSeconds(startTime),
      tts: Timing_exports2.MicroSeconds(startTime),
      pid: finalSendRequest.pid,
      tid: finalSendRequest.tid
    };
    const requests = map_utilities_exports.getWithDefault(requestsByOrigin, host, () => {
      return {
        renderBlocking: [],
        nonRenderBlocking: [],
        all: []
      };
    });
    if (networkEvent.args.data.renderBlocking === "non_blocking") {
      requests.nonRenderBlocking.push(networkEvent);
    } else {
      requests.renderBlocking.push(networkEvent);
    }
    requests.all.push(networkEvent);
    requestsByTime.push(networkEvent);
  }
  handlerState10 = 3 /* FINALIZED */;
}
function data16() {
  if (handlerState10 !== 3 /* FINALIZED */) {
    throw new Error("Network Request handler is not finalized");
  }
  return {
    byOrigin: new Map(requestsByOrigin),
    byTime: [...requestsByTime]
  };
}
function deps8() {
  return ["Meta"];
}

// front_end/models/trace/handlers/UserInteractionsHandler.ts
var UserInteractionsHandler_exports = {};
__export(UserInteractionsHandler_exports, {
  LONG_INTERACTION_THRESHOLD: () => LONG_INTERACTION_THRESHOLD,
  categoryOfInteraction: () => categoryOfInteraction,
  data: () => data17,
  finalize: () => finalize14,
  handleEvent: () => handleEvent17,
  removeNestedInteractions: () => removeNestedInteractions,
  reset: () => reset17
});
var allEvents2 = [];
var LONG_INTERACTION_THRESHOLD = Timing_exports3.millisecondsToMicroseconds(Timing_exports2.MilliSeconds(200));
var longestInteractionEvent = null;
var interactionEvents = [];
var interactionEventsWithNoNesting = [];
var eventTimingEndEventsById = /* @__PURE__ */ new Map();
var eventTimingStartEventsForInteractions = [];
var handlerState11 = 1 /* UNINITIALIZED */;
function reset17() {
  allEvents2.length = 0;
  interactionEvents.length = 0;
  eventTimingStartEventsForInteractions.length = 0;
  eventTimingEndEventsById.clear();
  interactionEventsWithNoNesting.length = 0;
  longestInteractionEvent = null;
  handlerState11 = 2 /* INITIALIZED */;
}
function handleEvent17(event) {
  if (handlerState11 !== 2 /* INITIALIZED */) {
    throw new Error("Handler is not initialized");
  }
  if (!TraceEvents_exports.isTraceEventEventTiming(event)) {
    return;
  }
  if (TraceEvents_exports.isTraceEventEventTimingEnd(event)) {
    eventTimingEndEventsById.set(event.id, event);
  }
  allEvents2.push(event);
  if (!event.args.data || !TraceEvents_exports.isTraceEventEventTimingStart(event)) {
    return;
  }
  const { duration, interactionId } = event.args.data;
  if (duration < 1 || interactionId === void 0 || interactionId === 0) {
    return;
  }
  eventTimingStartEventsForInteractions.push(event);
}
var pointerEventTypes = /* @__PURE__ */ new Set([
  "pointerdown",
  "touchstart",
  "pointerup",
  "touchend",
  "mousedown",
  "mouseup",
  "click"
]);
var keyboardEventTypes = /* @__PURE__ */ new Set([
  "keydown",
  "keypress",
  "keyup"
]);
function categoryOfInteraction(interaction) {
  if (pointerEventTypes.has(interaction.type)) {
    return "POINTER";
  }
  if (keyboardEventTypes.has(interaction.type)) {
    return "KEYBOARD";
  }
  return "OTHER";
}
function removeNestedInteractions(interactions) {
  const earliestEventForEndTimePerCategory = {
    POINTER: /* @__PURE__ */ new Map(),
    KEYBOARD: /* @__PURE__ */ new Map(),
    OTHER: /* @__PURE__ */ new Map()
  };
  function storeEventIfEarliestForCategoryAndEndTime(interaction) {
    const category = categoryOfInteraction(interaction);
    const earliestEventForEndTime = earliestEventForEndTimePerCategory[category];
    const endTime = Timing_exports2.MicroSeconds(interaction.ts + interaction.dur);
    const earliestCurrentEvent = earliestEventForEndTime.get(endTime);
    if (!earliestCurrentEvent) {
      earliestEventForEndTime.set(endTime, interaction);
      return;
    }
    if (interaction.ts < earliestCurrentEvent.ts) {
      earliestEventForEndTime.set(endTime, interaction);
    } else if (interaction.ts === earliestCurrentEvent.ts && interaction.interactionId === earliestCurrentEvent.interactionId) {
      const currentEventProcessingTime = earliestCurrentEvent.processingEnd - earliestCurrentEvent.processingStart;
      const newEventProcessingTime = interaction.processingEnd - interaction.processingStart;
      if (newEventProcessingTime > currentEventProcessingTime) {
        earliestEventForEndTime.set(endTime, interaction);
      }
    }
    if (interaction.processingStart < earliestCurrentEvent.processingStart) {
      earliestCurrentEvent.processingStart = interaction.processingStart;
      writeSyntheticTimespans(earliestCurrentEvent);
    }
    if (interaction.processingEnd > earliestCurrentEvent.processingEnd) {
      earliestCurrentEvent.processingEnd = interaction.processingEnd;
      writeSyntheticTimespans(earliestCurrentEvent);
    }
  }
  for (const interaction of interactions) {
    storeEventIfEarliestForCategoryAndEndTime(interaction);
  }
  const keptEvents = Object.values(earliestEventForEndTimePerCategory).flatMap((eventsByEndTime) => Array.from(eventsByEndTime.values()));
  keptEvents.sort((eventA, eventB) => {
    return eventA.ts - eventB.ts;
  });
  return keptEvents;
}
function writeSyntheticTimespans(event) {
  const startEvent = event.args.data.beginEvent;
  const endEvent = event.args.data.endEvent;
  event.inputDelay = Timing_exports2.MicroSeconds(event.processingStart - startEvent.ts);
  event.mainThreadHandling = Timing_exports2.MicroSeconds(event.processingEnd - event.processingStart);
  event.presentationDelay = Timing_exports2.MicroSeconds(endEvent.ts - event.processingEnd);
}
async function finalize14() {
  for (const interactionStartEvent of eventTimingStartEventsForInteractions) {
    const endEvent = eventTimingEndEventsById.get(interactionStartEvent.id);
    if (!endEvent) {
      continue;
    }
    if (!interactionStartEvent.args.data?.type || !interactionStartEvent.args.data?.interactionId) {
      continue;
    }
    const processingStartRelativeToTraceTime = Timing_exports2.MicroSeconds(Timing_exports3.millisecondsToMicroseconds(interactionStartEvent.args.data.processingStart) - Timing_exports3.millisecondsToMicroseconds(interactionStartEvent.args.data.timeStamp) + interactionStartEvent.ts);
    const processingEndRelativeToTraceTime = Timing_exports2.MicroSeconds(Timing_exports3.millisecondsToMicroseconds(interactionStartEvent.args.data.processingEnd) - Timing_exports3.millisecondsToMicroseconds(interactionStartEvent.args.data.timeStamp) + interactionStartEvent.ts);
    const interactionEvent = {
      cat: interactionStartEvent.cat,
      name: interactionStartEvent.name,
      pid: interactionStartEvent.pid,
      tid: interactionStartEvent.tid,
      ph: interactionStartEvent.ph,
      processingStart: processingStartRelativeToTraceTime,
      processingEnd: processingEndRelativeToTraceTime,
      inputDelay: Timing_exports2.MicroSeconds(-1),
      mainThreadHandling: Timing_exports2.MicroSeconds(-1),
      presentationDelay: Timing_exports2.MicroSeconds(-1),
      args: {
        data: {
          beginEvent: interactionStartEvent,
          endEvent
        }
      },
      ts: interactionStartEvent.ts,
      dur: Timing_exports2.MicroSeconds(endEvent.ts - interactionStartEvent.ts),
      type: interactionStartEvent.args.data.type,
      interactionId: interactionStartEvent.args.data.interactionId
    };
    writeSyntheticTimespans(interactionEvent);
    interactionEvents.push(interactionEvent);
  }
  handlerState11 = 3 /* FINALIZED */;
  interactionEventsWithNoNesting.push(...removeNestedInteractions(interactionEvents));
  for (const interactionEvent of interactionEventsWithNoNesting) {
    if (!longestInteractionEvent || longestInteractionEvent.dur < interactionEvent.dur) {
      longestInteractionEvent = interactionEvent;
    }
  }
}
function data17() {
  return {
    allEvents: [...allEvents2],
    interactionEvents: [...interactionEvents],
    interactionEventsWithNoNesting: [...interactionEventsWithNoNesting],
    longestInteractionEvent,
    interactionsOverThreshold: new Set(interactionEvents.filter((event) => {
      return event.dur > LONG_INTERACTION_THRESHOLD;
    }))
  };
}

// front_end/models/trace/handlers/UserTimingsHandler.ts
var UserTimingsHandler_exports = {};
__export(UserTimingsHandler_exports, {
  data: () => data18,
  finalize: () => finalize15,
  handleEvent: () => handleEvent18,
  reset: () => reset18
});
var syntheticEvents = [];
var performanceMeasureEvents = [];
var performanceMarkEvents = [];
var consoleTimings = [];
var timestampEvents = [];
var handlerState12 = 1 /* UNINITIALIZED */;
function reset18() {
  syntheticEvents.length = 0;
  performanceMeasureEvents.length = 0;
  performanceMarkEvents.length = 0;
  consoleTimings.length = 0;
  timestampEvents.length = 0;
  handlerState12 = 2 /* INITIALIZED */;
}
var resourceTimingNames = [
  "workerStart",
  "redirectStart",
  "redirectEnd",
  "fetchStart",
  "domainLookupStart",
  "domainLookupEnd",
  "connectStart",
  "connectEnd",
  "secureConnectionStart",
  "requestStart",
  "responseStart",
  "responseEnd"
];
var navTimingNames = [
  "navigationStart",
  "unloadEventStart",
  "unloadEventEnd",
  "redirectStart",
  "redirectEnd",
  "fetchStart",
  "commitNavigationEnd",
  "domainLookupStart",
  "domainLookupEnd",
  "connectStart",
  "connectEnd",
  "secureConnectionStart",
  "requestStart",
  "responseStart",
  "responseEnd",
  "domLoading",
  "domInteractive",
  "domContentLoadedEventStart",
  "domContentLoadedEventEnd",
  "domComplete",
  "loadEventStart",
  "loadEventEnd"
];
function handleEvent18(event) {
  if (handlerState12 !== 2 /* INITIALIZED */) {
    throw new Error("UserTimings handler is not initialized");
  }
  const ignoredNames = [...resourceTimingNames, ...navTimingNames];
  if (ignoredNames.includes(event.name)) {
    return;
  }
  if (TraceEvents_exports.isTraceEventPerformanceMeasure(event)) {
    performanceMeasureEvents.push(event);
    return;
  }
  if (TraceEvents_exports.isTraceEventPerformanceMark(event)) {
    performanceMarkEvents.push(event);
  }
  if (TraceEvents_exports.isTraceEventConsoleTime(event)) {
    consoleTimings.push(event);
  }
  if (TraceEvents_exports.isTraceEventTimeStamp(event)) {
    timestampEvents.push(event);
  }
}
async function finalize15() {
  if (handlerState12 !== 2 /* INITIALIZED */) {
    throw new Error("UserTimings handler is not initialized");
  }
  const asyncEvents = [...performanceMeasureEvents, ...consoleTimings];
  syntheticEvents.push(...Trace_exports.createMatchedSortedSyntheticEvents(asyncEvents));
  handlerState12 = 3 /* FINALIZED */;
}
function data18() {
  if (handlerState12 !== 3 /* FINALIZED */) {
    throw new Error("UserTimings handler is not finalized");
  }
  return {
    performanceMeasures: syntheticEvents.filter(TraceEvents_exports.isTraceEventPerformanceMeasure),
    consoleTimings: syntheticEvents.filter(TraceEvents_exports.isTraceEventConsoleTime),
    performanceMarks: [...performanceMarkEvents],
    timestampEvents: [...timestampEvents]
  };
}

// front_end/models/trace/handlers/WarningsHandler.ts
var WarningsHandler_exports = {};
__export(WarningsHandler_exports, {
  FORCED_LAYOUT_AND_STYLES_THRESHOLD: () => FORCED_LAYOUT_AND_STYLES_THRESHOLD,
  LONG_MAIN_THREAD_TASK_THRESHOLD: () => LONG_MAIN_THREAD_TASK_THRESHOLD,
  data: () => data19,
  deps: () => deps9,
  finalize: () => finalize16,
  handleEvent: () => handleEvent19,
  reset: () => reset19
});
var warningsPerEvent = /* @__PURE__ */ new Map();
var eventsPerWarning = /* @__PURE__ */ new Map();
var FORCED_LAYOUT_AND_STYLES_THRESHOLD = Timing_exports3.millisecondsToMicroseconds(Timing_exports2.MilliSeconds(10));
var LONG_MAIN_THREAD_TASK_THRESHOLD = Timing_exports3.millisecondsToMicroseconds(Timing_exports2.MilliSeconds(50));
function reset19() {
  warningsPerEvent.clear();
  eventsPerWarning.clear();
}
function storeWarning(event, warning) {
  const existingWarnings = map_utilities_exports.getWithDefault(warningsPerEvent, event, () => []);
  existingWarnings.push(warning);
  warningsPerEvent.set(event, existingWarnings);
  const existingEvents = map_utilities_exports.getWithDefault(eventsPerWarning, warning, () => []);
  existingEvents.push(event);
  eventsPerWarning.set(warning, existingEvents);
}
function handleEvent19(event) {
  if (event.name === TraceEvents_exports.KnownEventName.RunTask) {
    const { duration } = Timing_exports3.eventTimingsMicroSeconds(event);
    if (duration > LONG_MAIN_THREAD_TASK_THRESHOLD) {
      storeWarning(event, "LONG_TASK");
    }
    return;
  }
  if (TraceEvents_exports.isTraceEventFireIdleCallback(event)) {
    const { duration } = Timing_exports3.eventTimingsMilliSeconds(event);
    if (duration > event.args.data.allottedMilliseconds) {
      storeWarning(event, "IDLE_CALLBACK_OVER_TIME");
    }
    return;
  }
  if (event.name === TraceEvents_exports.KnownEventName.Layout) {
    if (event.dur && event.dur >= FORCED_LAYOUT_AND_STYLES_THRESHOLD) {
      storeWarning(event, "FORCED_LAYOUT");
    }
    return;
  }
  if (event.name === TraceEvents_exports.KnownEventName.RecalculateStyles || event.name === TraceEvents_exports.KnownEventName.UpdateLayoutTree) {
    if (event.dur && event.dur >= FORCED_LAYOUT_AND_STYLES_THRESHOLD) {
      storeWarning(event, "FORCED_STYLE");
    }
    return;
  }
}
function deps9() {
  return ["UserInteractions"];
}
async function finalize16() {
  const longInteractions = data17().interactionsOverThreshold;
  for (const interaction of longInteractions) {
    storeWarning(interaction, "LONG_INTERACTION");
  }
}
function data19() {
  return {
    perEvent: new Map(warningsPerEvent),
    perWarning: new Map(eventsPerWarning)
  };
}

// front_end/models/trace/handlers/WorkersHandler.ts
var WorkersHandler_exports = {};
__export(WorkersHandler_exports, {
  data: () => data20,
  finalize: () => finalize17,
  handleEvent: () => handleEvent20,
  initialize: () => initialize10,
  reset: () => reset20
});
var handlerState13 = 1 /* UNINITIALIZED */;
var sessionIdEvents = [];
var workerIdByThread = /* @__PURE__ */ new Map();
var workerURLById = /* @__PURE__ */ new Map();
function initialize10() {
  if (handlerState13 !== 1 /* UNINITIALIZED */) {
    throw new Error("Workers Handler was not reset");
  }
  handlerState13 = 2 /* INITIALIZED */;
}
function reset20() {
  sessionIdEvents.length = 0;
  workerIdByThread.clear();
  workerURLById.clear();
  handlerState13 = 1 /* UNINITIALIZED */;
}
function handleEvent20(event) {
  if (handlerState13 !== 2 /* INITIALIZED */) {
    throw new Error("Workers Handler is not initialized");
  }
  if (TraceEvents_exports.isTraceEventTracingSessionIdForWorker(event)) {
    sessionIdEvents.push(event);
  }
}
async function finalize17() {
  if (handlerState13 !== 2 /* INITIALIZED */) {
    throw new Error("Handler is not initialized");
  }
  for (const sessionIdEvent of sessionIdEvents) {
    if (!sessionIdEvent.args.data) {
      continue;
    }
    workerIdByThread.set(sessionIdEvent.args.data.workerThreadId, sessionIdEvent.args.data.workerId);
    workerURLById.set(sessionIdEvent.args.data.workerId, sessionIdEvent.args.data.url);
  }
  handlerState13 = 3 /* FINALIZED */;
}
function data20() {
  if (handlerState13 !== 3 /* FINALIZED */) {
    throw new Error("Workers Handler is not finalized");
  }
  return {
    workerSessionIdEvents: [...sessionIdEvents],
    workerIdByThread: new Map(workerIdByThread),
    workerURLById: new Map(workerURLById)
  };
}

// front_end/models/trace/LegacyTracingModel.ts
var LegacyTracingModel_exports = {};
__export(LegacyTracingModel_exports, {
  AsyncEvent: () => AsyncEvent,
  ConstructedEvent: () => ConstructedEvent,
  DevToolsMetadataEventCategory: () => DevToolsMetadataEventCategory,
  DevToolsTimelineEventCategory: () => DevToolsTimelineEventCategory,
  Event: () => Event2,
  LegacyTopLevelEventCategory: () => LegacyTopLevelEventCategory,
  MetadataEvent: () => MetadataEvent,
  ObjectSnapshot: () => ObjectSnapshot,
  PayloadEvent: () => PayloadEvent,
  Process: () => Process,
  Thread: () => Thread,
  TracingModel: () => TracingModel,
  eventHasCategory: () => eventHasCategory,
  eventHasPayload: () => eventHasPayload,
  eventIsFromNewEngine: () => eventIsFromNewEngine,
  eventPhasesOfInterestForTraceBounds: () => eventPhasesOfInterestForTraceBounds2,
  phaseForEvent: () => phaseForEvent,
  threadIDForEvent: () => threadIDForEvent,
  timesForEventInMilliseconds: () => timesForEventInMilliseconds
});
var TracingModel = class {
  #title;
  #processById;
  #processByName;
  #minimumRecordTimeInternal;
  #maximumRecordTimeInternal;
  #devToolsMetadataEventsInternal;
  #asyncEvents;
  #openAsyncEvents;
  #openNestableAsyncEvents;
  #profileGroups;
  #parsedCategories;
  #allEventsPayload = [];
  constructor(title) {
    this.#title = title;
    this.#processById = /* @__PURE__ */ new Map();
    this.#processByName = /* @__PURE__ */ new Map();
    this.#minimumRecordTimeInternal = Number(Infinity);
    this.#maximumRecordTimeInternal = Number(-Infinity);
    this.#devToolsMetadataEventsInternal = [];
    this.#asyncEvents = [];
    this.#openAsyncEvents = /* @__PURE__ */ new Map();
    this.#openNestableAsyncEvents = /* @__PURE__ */ new Map();
    this.#profileGroups = /* @__PURE__ */ new Map();
    this.#parsedCategories = /* @__PURE__ */ new Map();
  }
  static isTopLevelEvent(event) {
    return eventHasCategory(event, DevToolsTimelineEventCategory) && event.name === "RunTask" || eventHasCategory(event, LegacyTopLevelEventCategory) || eventHasCategory(event, DevToolsMetadataEventCategory) && event.name === "Program";
  }
  static extractId(payload) {
    const scope = payload.scope || "";
    if (typeof payload.id2 === "undefined") {
      return scope && payload.id ? `${scope}@${payload.id}` : payload.id;
    }
    const id2 = payload.id2;
    if (typeof id2 === "object" && "global" in id2 !== "local" in id2) {
      return typeof id2["global"] !== "undefined" ? `:${scope}:${id2["global"]}` : `:${scope}:${payload.pid}:${id2["local"]}`;
    }
    console.error(`Unexpected id2 field at ${payload.ts / 1e3}, one and only one of 'local' and 'global' should be present.`);
    return void 0;
  }
  static browserMainThread(tracingModel) {
    const processes2 = tracingModel.sortedProcesses();
    if (!processes2.length) {
      return null;
    }
    const browserMainThreadName = "CrBrowserMain";
    const browserProcesses = [];
    const browserMainThreads = [];
    for (const process of processes2) {
      if (process.name().toLowerCase().endsWith("browser")) {
        browserProcesses.push(process);
      }
      browserMainThreads.push(...process.sortedThreads().filter((t) => t.name() === browserMainThreadName));
    }
    if (browserMainThreads.length === 1) {
      return browserMainThreads[0];
    }
    if (browserProcesses.length === 1) {
      return browserProcesses[0].threadByName(browserMainThreadName);
    }
    const tracingStartedInBrowser = tracingModel.devToolsMetadataEvents().filter((e) => e.name === "TracingStartedInBrowser");
    if (tracingStartedInBrowser.length === 1) {
      return tracingStartedInBrowser[0].thread;
    }
    console.error("Failed to find browser main thread in trace, some timeline features may be unavailable");
    return null;
  }
  allRawEvents() {
    return this.#allEventsPayload;
  }
  devToolsMetadataEvents() {
    return this.#devToolsMetadataEventsInternal;
  }
  addEvents(events2) {
    for (let i = 0; i < events2.length; ++i) {
      this.addEvent(events2[i]);
    }
  }
  tracingComplete() {
    this.processPendingAsyncEvents();
    for (const process of this.#processById.values()) {
      for (const thread of process.threads.values()) {
        thread.tracingComplete();
      }
    }
  }
  addEvent(payload) {
    this.#allEventsPayload.push(payload);
    let process = this.#processById.get(payload.pid);
    if (!process) {
      process = new Process(this, payload.pid);
      this.#processById.set(payload.pid, process);
    }
    const timestamp = payload.ts / 1e3;
    if (timestamp && timestamp < this.#minimumRecordTimeInternal && eventPhasesOfInterestForTraceBounds2.has(payload.ph) && !payload.name.endsWith("::UMA")) {
      this.#minimumRecordTimeInternal = timestamp;
    }
    if (payload.name === "TracingStartedInBrowser") {
      this.#minimumRecordTimeInternal = timestamp;
    }
    if (eventPhasesOfInterestForTraceBounds2.has(payload.ph)) {
      const endTimeStamp = (payload.ts + (payload.dur || 0)) / 1e3;
      this.#maximumRecordTimeInternal = Math.max(this.#maximumRecordTimeInternal, endTimeStamp);
    }
    const event = process.addEvent(payload);
    if (!event) {
      return;
    }
    if (payload.ph === TraceEvents_exports.Phase.SAMPLE) {
      this.addSampleEvent(event);
      return;
    }
    if (TraceEvents_exports.isAsyncPhase(payload.ph)) {
      this.#asyncEvents.push(event);
    }
    if (event.hasCategory(DevToolsMetadataEventCategory)) {
      this.#devToolsMetadataEventsInternal.push(event);
    }
    if (payload.ph !== TraceEvents_exports.Phase.METADATA) {
      return;
    }
    switch (payload.name) {
      case MetadataEvent.ProcessSortIndex: {
        process.setSortIndex(payload.args["sort_index"]);
        break;
      }
      case MetadataEvent.ProcessName: {
        const processName = payload.args["name"];
        process.setName(processName);
        this.#processByName.set(processName, process);
        break;
      }
      case MetadataEvent.ThreadSortIndex: {
        process.threadById(payload.tid).setSortIndex(payload.args["sort_index"]);
        break;
      }
      case MetadataEvent.ThreadName: {
        process.threadById(payload.tid).setName(payload.args["name"]);
        break;
      }
    }
  }
  addSampleEvent(event) {
    const id = `${event.thread.process().id()}:${event.id}`;
    const group = this.#profileGroups.get(id);
    if (group) {
      group.addChild(event);
    } else {
      this.#profileGroups.set(id, new ProfileEventsGroup(event));
    }
  }
  profileGroup(event) {
    return this.#profileGroups.get(`${event.thread.process().id()}:${event.id}`) || null;
  }
  minimumRecordTime() {
    return this.#minimumRecordTimeInternal;
  }
  maximumRecordTime() {
    return this.#maximumRecordTimeInternal;
  }
  sortedProcesses() {
    return NamedObject.sort([...this.#processById.values()]);
  }
  getProcessByName(name) {
    return this.#processByName.get(name) ?? null;
  }
  getProcessById(pid) {
    return this.#processById.get(pid) || null;
  }
  getThreadByName(processName, threadName) {
    const process = this.getProcessByName(processName);
    return process && process.threadByName(threadName);
  }
  processPendingAsyncEvents() {
    this.#asyncEvents.sort(Event2.compareStartTime);
    for (let i = 0; i < this.#asyncEvents.length; ++i) {
      const event = this.#asyncEvents[i];
      if (TraceEvents_exports.isNestableAsyncPhase(event.phase)) {
        this.addNestableAsyncEvent(event);
      } else {
        this.addAsyncEvent(event);
      }
    }
    this.#asyncEvents = [];
    this.closeOpenAsyncEvents();
  }
  closeOpenAsyncEvents() {
    for (const event of this.#openAsyncEvents.values()) {
      event.setEndTime(this.#maximumRecordTimeInternal);
      event.steps[0].setEndTime(this.#maximumRecordTimeInternal);
    }
    this.#openAsyncEvents.clear();
    for (const eventStack of this.#openNestableAsyncEvents.values()) {
      while (eventStack.length) {
        const event = eventStack.pop();
        if (!event) {
          continue;
        }
        event.setEndTime(this.#maximumRecordTimeInternal);
      }
    }
    this.#openNestableAsyncEvents.clear();
  }
  addNestableAsyncEvent(event) {
    const key = event.categoriesString + "." + event.id;
    let openEventsStack = this.#openNestableAsyncEvents.get(key);
    switch (event.phase) {
      case TraceEvents_exports.Phase.ASYNC_NESTABLE_START: {
        if (!openEventsStack) {
          openEventsStack = [];
          this.#openNestableAsyncEvents.set(key, openEventsStack);
        }
        const asyncEvent = new AsyncEvent(event);
        openEventsStack.push(asyncEvent);
        event.thread.addAsyncEvent(asyncEvent);
        break;
      }
      case TraceEvents_exports.Phase.ASYNC_NESTABLE_INSTANT: {
        if (openEventsStack && openEventsStack.length) {
          const event2 = openEventsStack[openEventsStack.length - 1];
          if (event2) {
            event2.addStep(event2);
          }
        }
        break;
      }
      case TraceEvents_exports.Phase.ASYNC_NESTABLE_END: {
        if (!openEventsStack || !openEventsStack.length) {
          break;
        }
        const top = openEventsStack.pop();
        if (!top) {
          break;
        }
        if (top.name !== event.name) {
          console.error(`Begin/end event mismatch for nestable async event, ${top.name} vs. ${event.name}, key: ${key}`);
          break;
        }
        top.addStep(event);
      }
    }
  }
  addAsyncEvent(event) {
    const key = event.categoriesString + "." + event.name + "." + event.id;
    let asyncEvent = this.#openAsyncEvents.get(key);
    if (event.phase === TraceEvents_exports.Phase.ASYNC_BEGIN) {
      if (asyncEvent) {
        console.error(`Event ${event.name} has already been started`);
        return;
      }
      asyncEvent = new AsyncEvent(event);
      this.#openAsyncEvents.set(key, asyncEvent);
      event.thread.addAsyncEvent(asyncEvent);
      return;
    }
    if (!asyncEvent) {
      return;
    }
    if (event.phase === TraceEvents_exports.Phase.ASYNC_END) {
      asyncEvent.addStep(event);
      this.#openAsyncEvents.delete(key);
      return;
    }
    if (event.phase === TraceEvents_exports.Phase.ASYNC_STEP_INTO || event.phase === TraceEvents_exports.Phase.ASYNC_STEP_PAST) {
      const lastStep = asyncEvent.steps[asyncEvent.steps.length - 1];
      if (lastStep && lastStep.phase !== TraceEvents_exports.Phase.ASYNC_BEGIN && lastStep.phase !== event.phase) {
        console.assert(false, "Async event step phase mismatch: " + lastStep.phase + " at " + lastStep.startTime + " vs. " + event.phase + " at " + event.startTime);
        return;
      }
      asyncEvent.addStep(event);
      return;
    }
    console.assert(false, "Invalid async event phase");
  }
  title() {
    return this.#title;
  }
  parsedCategoriesForString(str) {
    let parsedCategories2 = this.#parsedCategories.get(str);
    if (!parsedCategories2) {
      parsedCategories2 = new Set(str ? str.split(",") : []);
      this.#parsedCategories.set(str, parsedCategories2);
    }
    return parsedCategories2;
  }
};
var eventPhasesOfInterestForTraceBounds2 = /* @__PURE__ */ new Set([
  TraceEvents_exports.Phase.BEGIN,
  TraceEvents_exports.Phase.END,
  TraceEvents_exports.Phase.COMPLETE,
  TraceEvents_exports.Phase.INSTANT
]);
var MetadataEvent = {
  ProcessSortIndex: "process_sort_index",
  ProcessName: "process_name",
  ThreadSortIndex: "thread_sort_index",
  ThreadName: "thread_name"
};
var LegacyTopLevelEventCategory = "toplevel";
var DevToolsMetadataEventCategory = "disabled-by-default-devtools.timeline";
var DevToolsTimelineEventCategory = "disabled-by-default-devtools.timeline";
function eventHasPayload(event) {
  return "rawPayload" in event;
}
var Event2 = class {
  categoriesString;
  #parsedCategories;
  name;
  phase;
  startTime;
  thread;
  args;
  id;
  ordinal;
  selfTime;
  endTime;
  duration;
  constructor(categories, name, phase, startTime, thread) {
    this.categoriesString = categories || "";
    this.#parsedCategories = thread.getModel().parsedCategoriesForString(this.categoriesString);
    this.name = name;
    this.phase = phase;
    this.startTime = startTime;
    this.thread = thread;
    this.args = {};
    this.ordinal = 0;
    this.selfTime = 0;
  }
  static compareStartTime(a, b) {
    if (!a || !b) {
      return 0;
    }
    return a.startTime - b.startTime;
  }
  static orderedCompareStartTime(a, b) {
    return a.startTime - b.startTime || a.ordinal - b.ordinal || -1;
  }
  hasCategory(categoryName) {
    return this.#parsedCategories.has(categoryName);
  }
  setEndTime(endTime) {
    if (endTime < this.startTime) {
      console.assert(false, "Event out of order: " + this.name);
      return;
    }
    this.endTime = endTime;
    this.duration = endTime - this.startTime;
  }
  addArgs(args) {
    for (const name in args) {
      if (name in this.args) {
        console.error("Same argument name (" + name + ") is used for begin and end phases of " + this.name);
      }
      this.args[name] = args[name];
    }
  }
  complete(endEvent) {
    if (endEvent.args) {
      this.addArgs(endEvent.args);
    } else {
      console.error("Missing mandatory event argument 'args' at " + endEvent.startTime);
    }
    this.setEndTime(endEvent.startTime);
  }
};
var ConstructedEvent = class extends Event2 {
  constructor(categories, name, phase, startTime, thread) {
    super(categories, name, phase, startTime, thread);
  }
};
var PayloadEvent = class extends Event2 {
  #rawPayload;
  rawLegacyPayload() {
    return this.#rawPayload;
  }
  rawPayload() {
    return this.#rawPayload;
  }
  constructor(categories, name, phase, startTime, thread, rawPayload) {
    super(categories, name, phase, startTime, thread);
    this.#rawPayload = rawPayload;
  }
  static fromPayload(payload, thread) {
    const event = new PayloadEvent(payload.cat, payload.name, payload.ph, payload.ts / 1e3, thread, payload);
    event.#rawPayload = payload;
    if (payload.args) {
      event.addArgs(payload.args);
    }
    if (typeof payload.dur === "number") {
      event.setEndTime((payload.ts + payload.dur) / 1e3);
    }
    const id = TracingModel.extractId(payload);
    if (typeof id !== "undefined") {
      event.id = id;
    }
    return event;
  }
};
var ObjectSnapshot = class extends PayloadEvent {
  constructor(category, name, startTime, thread, rawPayload) {
    super(category, name, TraceEvents_exports.Phase.OBJECT_SNAPSHOT, startTime, thread, rawPayload);
  }
  static fromPayload(payload, thread) {
    const snapshot = new ObjectSnapshot(payload.cat, payload.name, payload.ts / 1e3, thread, payload);
    const id = TracingModel.extractId(payload);
    if (typeof id !== "undefined") {
      snapshot.id = id;
    }
    if (!payload.args || !payload.args["snapshot"]) {
      console.error("Missing mandatory 'snapshot' argument at " + payload.ts / 1e3);
      return snapshot;
    }
    if (payload.args) {
      snapshot.addArgs(payload.args);
    }
    return snapshot;
  }
  getSnapshot() {
    const snapshot = this.args["snapshot"];
    if (!snapshot) {
      throw new Error("ObjectSnapshot has no snapshot argument.");
    }
    return snapshot;
  }
};
var AsyncEvent = class extends ConstructedEvent {
  steps;
  causedFrame;
  constructor(startEvent) {
    super(startEvent.categoriesString, startEvent.name, startEvent.phase, startEvent.startTime, startEvent.thread);
    this.addArgs(startEvent.args);
    this.steps = [startEvent];
    this.causedFrame = false;
  }
  addStep(event) {
    this.steps.push(event);
    if (event.phase === TraceEvents_exports.Phase.ASYNC_END || event.phase === TraceEvents_exports.Phase.ASYNC_NESTABLE_END) {
      this.setEndTime(event.startTime);
      this.steps[0].setEndTime(event.startTime);
    }
  }
};
var ProfileEventsGroup = class {
  children;
  constructor(event) {
    this.children = [event];
  }
  addChild(event) {
    this.children.push(event);
  }
};
var NamedObject = class {
  model;
  idInternal;
  #nameInternal;
  #sortIndex;
  constructor(model2, id) {
    this.model = model2;
    this.idInternal = id;
    this.#nameInternal = "";
    this.#sortIndex = 0;
  }
  static sort(array) {
    return array.sort((a, b) => {
      return a.#sortIndex !== b.#sortIndex ? a.#sortIndex - b.#sortIndex : a.name().localeCompare(b.name());
    });
  }
  setName(name) {
    this.#nameInternal = name;
  }
  name() {
    return this.#nameInternal;
  }
  id() {
    return this.idInternal;
  }
  setSortIndex(sortIndex) {
    this.#sortIndex = sortIndex;
  }
  getModel() {
    return this.model;
  }
};
var Process = class extends NamedObject {
  threads;
  #threadByNameInternal;
  constructor(model2, id) {
    super(model2, id);
    this.threads = /* @__PURE__ */ new Map();
    this.#threadByNameInternal = /* @__PURE__ */ new Map();
  }
  threadById(id) {
    let thread = this.threads.get(id);
    if (!thread) {
      thread = new Thread(this, id);
      this.threads.set(id, thread);
    }
    return thread;
  }
  threadByName(name) {
    return this.#threadByNameInternal.get(name) || null;
  }
  setThreadByName(name, thread) {
    this.#threadByNameInternal.set(name, thread);
  }
  addEvent(payload) {
    return this.threadById(payload.tid).addEvent(payload);
  }
  sortedThreads() {
    return NamedObject.sort([...this.threads.values()]);
  }
};
var Thread = class extends NamedObject {
  #processInternal;
  #eventsInternal;
  #asyncEventsInternal;
  #lastTopLevelEvent;
  constructor(process, id) {
    super(process.getModel(), id);
    this.#processInternal = process;
    this.#eventsInternal = [];
    this.#asyncEventsInternal = [];
    this.#lastTopLevelEvent = null;
  }
  #eventMatchesPhase(event, phase) {
    return event.phase === phase;
  }
  tracingComplete() {
    this.#asyncEventsInternal.sort(Event2.compareStartTime);
    this.#eventsInternal.sort(Event2.compareStartTime);
    const stack = [];
    const toDelete = /* @__PURE__ */ new Set();
    for (let i = 0; i < this.#eventsInternal.length; ++i) {
      const e = this.#eventsInternal[i];
      e.ordinal = i;
      if (this.#eventMatchesPhase(e, TraceEvents_exports.Phase.END)) {
        toDelete.add(i);
        if (!stack.length) {
          continue;
        }
        const top = stack.pop();
        if (!top) {
          continue;
        }
        if (top.name !== e.name || top.categoriesString !== e.categoriesString) {
          console.error("B/E events mismatch at " + top.startTime + " (" + top.name + ") vs. " + e.startTime + " (" + e.name + ")");
        } else {
          top.complete(e);
        }
      } else if (this.#eventMatchesPhase(e, TraceEvents_exports.Phase.BEGIN)) {
        stack.push(e);
      }
    }
    while (stack.length) {
      const event = stack.pop();
      if (event) {
        event.phase = TraceEvents_exports.Phase.INSTANT;
      }
    }
    this.#eventsInternal = this.#eventsInternal.filter((_, idx) => !toDelete.has(idx));
  }
  addEvent(payload) {
    const event = payload.ph === TraceEvents_exports.Phase.OBJECT_SNAPSHOT ? ObjectSnapshot.fromPayload(payload, this) : PayloadEvent.fromPayload(payload, this);
    if (TracingModel.isTopLevelEvent(event)) {
      const lastTopLevelEvent = this.#lastTopLevelEvent;
      if (lastTopLevelEvent && (lastTopLevelEvent.endTime || 0) > event.startTime) {
        return null;
      }
      this.#lastTopLevelEvent = event;
    }
    this.#eventsInternal.push(event);
    return event;
  }
  addAsyncEvent(asyncEvent) {
    this.#asyncEventsInternal.push(asyncEvent);
  }
  setName(name) {
    super.setName(name);
    this.#processInternal.setThreadByName(name, this);
  }
  process() {
    return this.#processInternal;
  }
  events() {
    return this.#eventsInternal;
  }
  asyncEvents() {
    return this.#asyncEventsInternal;
  }
  removeEventsByName(name) {
    const extracted = [];
    this.#eventsInternal = this.#eventsInternal.filter((e) => {
      if (!e) {
        return false;
      }
      if (e.name !== name) {
        return true;
      }
      extracted.push(e);
      return false;
    });
    return extracted;
  }
};
function timesForEventInMilliseconds(event) {
  if (event instanceof Event2) {
    return {
      startTime: Timing_exports2.MilliSeconds(event.startTime),
      endTime: event.endTime ? Timing_exports2.MilliSeconds(event.endTime) : void 0,
      duration: Timing_exports2.MilliSeconds(event.duration || 0),
      selfTime: Timing_exports2.MilliSeconds(event.selfTime)
    };
  }
  return Timing_exports3.eventTimingsMilliSeconds(event);
}
var parsedCategories = /* @__PURE__ */ new Map();
function eventHasCategory(event, category) {
  if (event instanceof Event2) {
    return event.hasCategory(category);
  }
  let parsedCategoriesForEvent = parsedCategories.get(event.cat);
  if (!parsedCategoriesForEvent) {
    parsedCategoriesForEvent = new Set(event.cat.split(",") || []);
  }
  return parsedCategoriesForEvent.has(category);
}
function phaseForEvent(event) {
  if (event instanceof Event2) {
    return event.phase;
  }
  return event.ph;
}
function threadIDForEvent(event) {
  if (event instanceof Event2) {
    return event.thread.idInternal;
  }
  return event.tid;
}
function eventIsFromNewEngine(event) {
  return event !== null && !(event instanceof Event2);
}

// front_end/models/trace/ModelImpl.ts
var ModelImpl_exports = {};
__export(ModelImpl_exports, {
  Model: () => Model,
  ModelUpdateEvent: () => ModelUpdateEvent,
  ModelUpdateType: () => ModelUpdateType,
  isModelUpdateDataComplete: () => isModelUpdateDataComplete,
  isModelUpdateDataProgress: () => isModelUpdateDataProgress
});

// front_end/models/trace/Processor.ts
var Processor_exports = {};
__export(Processor_exports, {
  TraceParseProgressEvent: () => TraceParseProgressEvent,
  TraceProcessor: () => TraceProcessor,
  sortHandlers: () => sortHandlers
});
var _TraceParseProgressEvent = class extends Event {
  constructor(data21, init = { bubbles: true }) {
    super(_TraceParseProgressEvent.eventName, init);
    this.data = data21;
  }
};
var TraceParseProgressEvent = _TraceParseProgressEvent;
__publicField(TraceParseProgressEvent, "eventName", "traceparseprogress");
var TraceProcessor = class extends EventTarget {
  #traceHandlers;
  #status = "IDLE" /* IDLE */;
  #modelConfiguration = Configuration_exports.DEFAULT;
  static createWithAllHandlers() {
    return new TraceProcessor(ModelHandlers_exports, Configuration_exports.DEFAULT);
  }
  constructor(traceHandlers, modelConfiguration) {
    super();
    this.#verifyHandlers(traceHandlers);
    this.#traceHandlers = {
      Meta: ModelHandlers_exports.Meta,
      ...traceHandlers
    };
    if (modelConfiguration) {
      this.#modelConfiguration = modelConfiguration;
    }
    this.#passConfigToHandlers();
  }
  updateConfiguration(config2) {
    this.#modelConfiguration = config2;
    this.#passConfigToHandlers();
  }
  #passConfigToHandlers() {
    for (const handler of Object.values(this.#traceHandlers)) {
      if ("handleUserConfig" in handler && handler.handleUserConfig) {
        handler.handleUserConfig(this.#modelConfiguration);
      }
    }
  }
  #verifyHandlers(providedHandlers) {
    if (Object.keys(providedHandlers).length === Object.keys(ModelHandlers_exports).length) {
      return;
    }
    const requiredHandlerKeys = /* @__PURE__ */ new Set();
    for (const [handlerName, handler] of Object.entries(providedHandlers)) {
      requiredHandlerKeys.add(handlerName);
      for (const depName of handler.deps?.() || []) {
        requiredHandlerKeys.add(depName);
      }
    }
    const providedHandlerKeys = new Set(Object.keys(providedHandlers));
    requiredHandlerKeys.delete("Meta");
    for (const requiredKey of requiredHandlerKeys) {
      if (!providedHandlerKeys.has(requiredKey)) {
        throw new Error(`Required handler ${requiredKey} not provided.`);
      }
    }
  }
  reset() {
    if (this.#status === "PARSING" /* PARSING */) {
      throw new Error("Trace processor can't reset while parsing.");
    }
    const handlers = Object.values(this.#traceHandlers);
    for (const handler of handlers) {
      handler.reset();
    }
    this.#status = "IDLE" /* IDLE */;
  }
  async parse(traceEvents, freshRecording = false) {
    if (this.#status !== "IDLE" /* IDLE */) {
      throw new Error(`Trace processor can't start parsing when not idle. Current state: ${this.#status}`);
    }
    try {
      this.#status = "PARSING" /* PARSING */;
      await this.#parse(traceEvents, freshRecording);
      this.#status = "FINISHED_PARSING" /* FINISHED_PARSING */;
    } catch (e) {
      this.#status = "ERRORED_WHILE_PARSING" /* ERRORED_WHILE_PARSING */;
      throw e;
    }
  }
  async #parse(traceEvents, freshRecording) {
    const { pauseDuration, eventsPerChunk } = this.#modelConfiguration.processing;
    const traceEventIterator = new TraceEventIterator(traceEvents, pauseDuration, eventsPerChunk);
    const sortedHandlers = [...sortHandlers(this.#traceHandlers).values()];
    for (const handler of sortedHandlers) {
      handler.reset();
    }
    for (const handler of sortedHandlers) {
      handler.initialize?.(freshRecording);
    }
    for await (const item of traceEventIterator) {
      if (item.kind === IteratorItemType.STATUS_UPDATE) {
        this.dispatchEvent(new TraceParseProgressEvent(item.data));
        continue;
      }
      for (const handler of sortedHandlers) {
        handler.handleEvent(item.data);
      }
    }
    for (const handler of sortedHandlers) {
      await handler.finalize?.();
    }
  }
  get data() {
    if (this.#status !== "FINISHED_PARSING" /* FINISHED_PARSING */) {
      return null;
    }
    const data21 = {};
    for (const [name, handler] of Object.entries(this.#traceHandlers)) {
      Object.assign(data21, { [name]: handler.data() });
    }
    return data21;
  }
};
function sortHandlers(traceHandlers) {
  const sortedMap = /* @__PURE__ */ new Map();
  const visited = /* @__PURE__ */ new Set();
  const visitHandler = (handlerName) => {
    if (sortedMap.has(handlerName)) {
      return;
    }
    if (visited.has(handlerName)) {
      let stackPath = "";
      for (const handler2 of visited) {
        if (stackPath || handler2 === handlerName) {
          stackPath += `${handler2}->`;
        }
      }
      stackPath += handlerName;
      throw new Error(`Found dependency cycle in trace event handlers: ${stackPath}`);
    }
    visited.add(handlerName);
    const handler = traceHandlers[handlerName];
    if (!handler) {
      return;
    }
    const deps10 = handler.deps?.();
    if (deps10) {
      deps10.forEach(visitHandler);
    }
    sortedMap.set(handlerName, handler);
  };
  for (const handlerName of Object.keys(traceHandlers)) {
    visitHandler(handlerName);
  }
  return sortedMap;
}
var IteratorItemType = /* @__PURE__ */ ((IteratorItemType2) => {
  IteratorItemType2[IteratorItemType2["TRACE_EVENT"] = 1] = "TRACE_EVENT";
  IteratorItemType2[IteratorItemType2["STATUS_UPDATE"] = 2] = "STATUS_UPDATE";
  return IteratorItemType2;
})(IteratorItemType || {});
var TraceEventIterator = class {
  constructor(traceEvents, pauseDuration, eventsPerChunk) {
    this.traceEvents = traceEvents;
    this.pauseDuration = pauseDuration;
    this.eventsPerChunk = eventsPerChunk;
    this.#eventCount = 0;
  }
  #eventCount;
  async *[Symbol.asyncIterator]() {
    for (let i = 0, length = this.traceEvents.length; i < length; i++) {
      if (++this.#eventCount % this.eventsPerChunk === 0) {
        yield { kind: 2 /* STATUS_UPDATE */, data: { index: i, total: length } };
        await new Promise((resolve) => setTimeout(resolve, this.pauseDuration));
      }
      yield { kind: 1 /* TRACE_EVENT */, data: this.traceEvents[i] };
    }
  }
};

// front_end/models/trace/ModelImpl.ts
var Model = class extends EventTarget {
  #traces = [];
  #nextNumberByDomain = /* @__PURE__ */ new Map();
  #recordingsAvailable = [];
  #lastRecordingIndex = 0;
  #processor;
  #config = Configuration_exports.DEFAULT;
  static createWithAllHandlers(config2) {
    return new Model(ModelHandlers_exports, config2);
  }
  constructor(handlers, config2) {
    super();
    if (config2) {
      this.#config = config2;
    }
    this.#processor = new TraceProcessor(handlers, this.#config);
  }
  updateConfiguration(config2) {
    this.#config = config2;
    this.#processor.updateConfiguration(config2);
  }
  async parse(traceEvents, config2) {
    const metadata = config2?.metadata || {};
    const isFreshRecording = config2?.isFreshRecording || false;
    const onTraceUpdate = (event) => {
      const { data: data21 } = event;
      this.dispatchEvent(new ModelUpdateEvent({ type: ModelUpdateType.PROGRESS_UPDATE, data: data21 }));
    };
    this.#processor.addEventListener(TraceParseProgressEvent.eventName, onTraceUpdate);
    const file = {
      traceEvents,
      metadata,
      traceParsedData: null
    };
    try {
      await this.#processor.parse(traceEvents, isFreshRecording);
      this.#storeParsedFileData(file, this.#processor.data);
      this.#traces.push(file);
    } catch (e) {
      throw e;
    } finally {
      this.#processor.removeEventListener(TraceParseProgressEvent.eventName, onTraceUpdate);
      this.dispatchEvent(new ModelUpdateEvent({ type: ModelUpdateType.COMPLETE, data: "done" }));
    }
  }
  #storeParsedFileData(file, data21) {
    file.traceParsedData = data21;
    this.#lastRecordingIndex++;
    let recordingName = `Trace ${this.#lastRecordingIndex}`;
    let origin = null;
    if (file.traceParsedData) {
      origin = Trace_exports.extractOriginFromTrace(file.traceParsedData.Meta.mainFrameURL);
      if (origin) {
        const nextSequenceForDomain = map_utilities_exports.getWithDefault(this.#nextNumberByDomain, origin, () => 1);
        recordingName = `${origin} (${nextSequenceForDomain})`;
        this.#nextNumberByDomain.set(origin, nextSequenceForDomain + 1);
      }
    }
    this.#recordingsAvailable.push(recordingName);
  }
  traceParsedData(index = this.#traces.length - 1) {
    if (!this.#traces[index]) {
      return null;
    }
    return this.#traces[index].traceParsedData;
  }
  metadata(index) {
    if (!this.#traces[index]) {
      return null;
    }
    return this.#traces[index].metadata;
  }
  traceEvents(index) {
    if (!this.#traces[index]) {
      return null;
    }
    return this.#traces[index].traceEvents;
  }
  size() {
    return this.#traces.length;
  }
  deleteTraceByIndex(recordingIndex) {
    this.#traces.splice(recordingIndex, 1);
    this.#recordingsAvailable.splice(recordingIndex, 1);
  }
  getRecordingsAvailable() {
    return this.#recordingsAvailable;
  }
  resetProcessor() {
    this.#processor.reset();
  }
};
var ModelUpdateType = /* @__PURE__ */ ((ModelUpdateType2) => {
  ModelUpdateType2["COMPLETE"] = "COMPLETE";
  ModelUpdateType2["PROGRESS_UPDATE"] = "PROGRESS_UPDATE";
  return ModelUpdateType2;
})(ModelUpdateType || {});
var _ModelUpdateEvent = class extends Event {
  constructor(data21) {
    super(_ModelUpdateEvent.eventName);
    this.data = data21;
  }
};
var ModelUpdateEvent = _ModelUpdateEvent;
__publicField(ModelUpdateEvent, "eventName", "modelupdate");
function isModelUpdateDataComplete(eventData) {
  return eventData.type === "COMPLETE" /* COMPLETE */;
}
function isModelUpdateDataProgress(eventData) {
  return eventData.type === "PROGRESS_UPDATE" /* PROGRESS_UPDATE */;
}

// front_end/models/trace/root-causes/root-causes.ts
var root_causes_exports = {};
__export(root_causes_exports, {
  RootCauses: () => RootCauses_exports
});

// front_end/models/trace/root-causes/RootCauses.ts
var RootCauses_exports = {};
__export(RootCauses_exports, {
  RootCauses: () => RootCauses
});

// front_end/models/trace/root-causes/LayoutShift.ts
var fontRequestsByPrePaint = /* @__PURE__ */ new Map();
var renderBlocksByPrePaint = /* @__PURE__ */ new Map();
function setDefaultValue(map, shift) {
  map_utilities_exports.getWithDefault(map, shift, () => {
    return {
      unsizedMedia: [],
      iframes: [],
      fontChanges: [],
      renderBlockingRequests: [],
      scriptStackTrace: []
    };
  });
}
var NON_RENDER_BLOCKING_VALUES = /* @__PURE__ */ new Set([
  "non_blocking",
  "potentially_blocking"
]);
function networkRequestIsRenderBlockingInFrame(event, frameId) {
  const isRenderBlocking = !NON_RENDER_BLOCKING_VALUES.has(event.args.data.renderBlocking);
  return isRenderBlocking && event.args.data.frame === frameId;
}
var LayoutShiftRootCauses = class {
  #protocolInterface;
  #rootCauseCacheMap = /* @__PURE__ */ new Map();
  constructor(protocolInterface) {
    this.#protocolInterface = protocolInterface;
  }
  async rootCausesForEvent(modelData, event) {
    const cachedResult = this.#rootCauseCacheMap.get(event);
    if (cachedResult) {
      return cachedResult;
    }
    const allLayoutShifts = modelData.LayoutShifts.clusters.flatMap((cluster) => cluster.events);
    allLayoutShifts.forEach((shift) => setDefaultValue(this.#rootCauseCacheMap, shift));
    await this.blameShifts(allLayoutShifts, modelData);
    const resultForEvent = this.#rootCauseCacheMap.get(event);
    if (!resultForEvent) {
      return null;
    }
    return resultForEvent;
  }
  async blameShifts(layoutShifts, modelData) {
    await this.linkShiftsToLayoutInvalidations(layoutShifts, modelData);
    this.linkShiftsToLayoutEvents(layoutShifts, modelData);
  }
  async linkShiftsToLayoutInvalidations(layoutShifts, modelData) {
    const { prePaintEvents: prePaintEvents2, layoutInvalidationEvents: liEvents, backendNodeIds: backendNodeIds2 } = modelData.LayoutShifts;
    const nodes = await this.#protocolInterface.pushNodesByBackendIdsToFrontend(backendNodeIds2);
    const nodeIdsByBackendIdMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < backendNodeIds2.length; i++) {
      nodeIdsByBackendIdMap.set(backendNodeIds2[i], nodes[i]);
    }
    const shiftsByPrePaint = getShiftsByPrePaintEvents(layoutShifts, prePaintEvents2);
    for (const layoutInvalidation of liEvents) {
      const nextPrePaintIndex = array_utilities_exports.nearestIndexFromBeginning(prePaintEvents2, (prePaint) => prePaint.ts > layoutInvalidation.ts);
      if (nextPrePaintIndex === null) {
        continue;
      }
      const nextPrePaint = prePaintEvents2[nextPrePaintIndex];
      const subsequentShifts = shiftsByPrePaint.get(nextPrePaint);
      if (!subsequentShifts) {
        continue;
      }
      const fontChangeRootCause = this.getFontChangeRootCause(layoutInvalidation, nextPrePaint, modelData);
      const renderBlockRootCause = this.getRenderBlockRootCause(layoutInvalidation, nextPrePaint, modelData);
      const layoutInvalidationNodeId = nodeIdsByBackendIdMap.get(layoutInvalidation.args.data.nodeId);
      const layoutInvalidationNode = layoutInvalidationNodeId !== void 0 ? await this.#protocolInterface.getNode(layoutInvalidationNodeId) : null;
      let unsizedMediaRootCause = null;
      let iframeRootCause = null;
      if (layoutInvalidationNode) {
        unsizedMediaRootCause = await this.getUnsizedMediaRootCause(layoutInvalidation.args.data.reason, layoutInvalidationNode);
        iframeRootCause = await this.getIframeRootCause(layoutInvalidation.args.data.reason, layoutInvalidationNode);
      }
      if (!unsizedMediaRootCause && !iframeRootCause && !fontChangeRootCause && !renderBlockRootCause) {
        continue;
      }
      for (const shift of subsequentShifts) {
        const rootCausesForShift = map_utilities_exports.getWithDefault(this.#rootCauseCacheMap, shift, () => {
          return {
            unsizedMedia: [],
            iframes: [],
            fontChanges: [],
            renderBlockingRequests: [],
            scriptStackTrace: []
          };
        });
        if (unsizedMediaRootCause && !rootCausesForShift.unsizedMedia.some((media) => media.node.nodeId === unsizedMediaRootCause?.node.nodeId) && shift.args.frame === layoutInvalidation.args.data.frame) {
          rootCausesForShift.unsizedMedia.push(unsizedMediaRootCause);
        }
        if (iframeRootCause && !rootCausesForShift.iframes.some((injectedIframe) => injectedIframe.iframe.nodeId === iframeRootCause?.iframe.nodeId)) {
          rootCausesForShift.iframes.push(iframeRootCause);
        }
        if (fontChangeRootCause) {
          rootCausesForShift.fontChanges = fontChangeRootCause;
        }
        if (renderBlockRootCause) {
          rootCausesForShift.renderBlockingRequests = renderBlockRootCause;
        }
      }
    }
  }
  linkShiftsToLayoutEvents(layoutShifts, modelData) {
    const { prePaintEvents: prePaintEvents2 } = modelData.LayoutShifts;
    const shiftsByPrePaint = getShiftsByPrePaintEvents(layoutShifts, prePaintEvents2);
    const eventTriggersLayout = ({ name }) => {
      const knownName = name;
      return knownName === TraceEvents_exports.KnownEventName.Layout;
    };
    const layoutEvents = modelData.Renderer.allTraceEntries.filter(eventTriggersLayout);
    for (const layout of layoutEvents) {
      const nextPrePaintIndex = array_utilities_exports.nearestIndexFromBeginning(prePaintEvents2, (prePaint) => prePaint.ts > layout.ts + (layout.dur || 0));
      if (nextPrePaintIndex === null) {
        continue;
      }
      const nextPrePaint = prePaintEvents2[nextPrePaintIndex];
      const subsequentShifts = shiftsByPrePaint.get(nextPrePaint);
      if (!subsequentShifts) {
        continue;
      }
      const layoutNode = modelData.Renderer.entryToNode.get(layout);
      const initiator = layoutNode ? modelData.Initiators.eventToInitiator.get(layoutNode.entry) : null;
      const stackTrace = initiator?.args?.data?.stackTrace;
      if (!stackTrace) {
        continue;
      }
      for (const shift of subsequentShifts) {
        const rootCausesForShift = map_utilities_exports.getWithDefault(this.#rootCauseCacheMap, shift, () => {
          return {
            unsizedMedia: [],
            iframes: [],
            fontChanges: [],
            renderBlockingRequests: [],
            scriptStackTrace: []
          };
        });
        if (rootCausesForShift.scriptStackTrace.length === 0) {
          rootCausesForShift.scriptStackTrace = stackTrace;
        }
      }
    }
  }
  async getUnsizedMediaRootCause(reason, layoutInvalidationNode) {
    if (reason !== TraceEvents_exports.LayoutInvalidationReason.SIZE_CHANGED) {
      return null;
    }
    const computedStylesList = await this.#protocolInterface.getComputedStyleForNode(layoutInvalidationNode.nodeId);
    const computedStyles = new Map(computedStylesList.map((item) => [item.name, item.value]));
    if (computedStyles && !await nodeIsUnfixedMedia(layoutInvalidationNode, computedStyles)) {
      return null;
    }
    const authoredDimensions = await this.getNodeAuthoredDimensions(layoutInvalidationNode);
    if (dimensionsAreExplicit(authoredDimensions)) {
      return null;
    }
    const computedDimensions = computedStyles ? getNodeComputedDimensions(computedStyles) : {};
    return { node: layoutInvalidationNode, authoredDimensions, computedDimensions };
  }
  getIframeRootCause(reason, layoutInvalidationDOMNode) {
    if (layoutInvalidationDOMNode.nodeName !== "IFRAME" && reason !== TraceEvents_exports.LayoutInvalidationReason.STYLE_CHANGED && reason !== TraceEvents_exports.LayoutInvalidationReason.ADDED_TO_LAYOUT) {
      return null;
    }
    const iframe = firstIframeInDOMTree(layoutInvalidationDOMNode);
    if (!iframe) {
      return null;
    }
    return { iframe };
  }
  requestsInInvalidationWindow(layoutInvalidation, modelData) {
    const requestsSortedByEndTime = modelData.NetworkRequests.byTime.sort((req1, req2) => {
      const req1EndTime = req1.ts + req1.dur;
      const req2EndTime = req2.ts + req2.dur;
      return req1EndTime - req2EndTime;
    });
    const lastRequestIndex = array_utilities_exports.nearestIndexFromEnd(requestsSortedByEndTime, (request) => request.ts + request.dur < layoutInvalidation.ts);
    if (lastRequestIndex === null) {
      return [];
    }
    const MAX_DELTA_FOR_FONT_REQUEST = Timing_exports3.secondsToMicroseconds(Timing_exports2.Seconds(0.5));
    const requestsInInvalidationWindow = [];
    for (let i = lastRequestIndex; i > -1; i--) {
      const previousRequest = requestsSortedByEndTime[i];
      const previousRequestEndTime = previousRequest.ts + previousRequest.dur;
      if (layoutInvalidation.ts - previousRequestEndTime < MAX_DELTA_FOR_FONT_REQUEST) {
        const requestInInvalidationWindow = { request: previousRequest };
        const initiator = this.#protocolInterface.getInitiatorForRequest(previousRequest.args.data.url);
        requestInInvalidationWindow.initiator = initiator || void 0;
        requestsInInvalidationWindow.push(requestInInvalidationWindow);
      } else {
        break;
      }
    }
    return requestsInInvalidationWindow;
  }
  getFontChangeRootCause(layoutInvalidation, nextPrePaint, modelData) {
    if (layoutInvalidation.args.data.reason !== TraceEvents_exports.LayoutInvalidationReason.FONTS_CHANGED) {
      return null;
    }
    const fontRequestsForPrepaint = fontRequestsByPrePaint.get(nextPrePaint);
    if (fontRequestsForPrepaint !== void 0) {
      return fontRequestsForPrepaint;
    }
    const fontRequestsInThisPrepaint = this.getFontRequestsInInvalidationWindow(this.requestsInInvalidationWindow(layoutInvalidation, modelData));
    fontRequestsByPrePaint.set(nextPrePaint, fontRequestsInThisPrepaint);
    return fontRequestsInThisPrepaint;
  }
  getFontRequestsInInvalidationWindow(requestsInInvalidationWindow) {
    const fontRequests = [];
    for (let i = 0; i < requestsInInvalidationWindow.length; i++) {
      const fontRequest = requestsInInvalidationWindow[i];
      if (!fontRequest.request.args.data.mimeType.startsWith("font")) {
        continue;
      }
      const fontFace = this.#protocolInterface.fontFaceForSource(fontRequest.request.args.data.url);
      if (!fontFace || fontFace.fontDisplay === "optional") {
        continue;
      }
      fontRequest.fontFace = fontFace;
      fontRequests.push(fontRequest);
    }
    return fontRequests;
  }
  getRenderBlockRootCause(layoutInvalidation, nextPrePaint, modelData) {
    const renderBlocksInPrepaint = renderBlocksByPrePaint.get(nextPrePaint);
    if (renderBlocksInPrepaint !== void 0) {
      return renderBlocksInPrepaint;
    }
    const renderBlocksInThisPrepaint = getRenderBlockRequestsInInvalidationWindow(this.requestsInInvalidationWindow(layoutInvalidation, modelData));
    renderBlocksByPrePaint.set(nextPrePaint, renderBlocksInThisPrepaint);
    return renderBlocksInThisPrepaint;
  }
  async nodeMatchedStylesPropertyGetter(node) {
    const response = await this.#protocolInterface.getMatchedStylesForNode(node.nodeId);
    function cssPropertyValueGetter(cssProperty) {
      let prop = response.inlineStyle?.cssProperties.find((prop2) => prop2.name === cssProperty);
      if (prop) {
        return prop.value;
      }
      for (const { rule } of response.matchedCSSRules || []) {
        const prop2 = rule.style.cssProperties.find((prop3) => prop3.name === cssProperty);
        if (prop2) {
          return prop2.value;
        }
      }
      prop = response.attributesStyle?.cssProperties.find((prop2) => prop2.name === cssProperty);
      if (prop) {
        return prop.value;
      }
      return null;
    }
    return cssPropertyValueGetter;
  }
  async getNodeAuthoredDimensions(node) {
    const authoredDimensions = {};
    const cssMatchedRulesGetter = await this.nodeMatchedStylesPropertyGetter(node);
    if (!cssMatchedRulesGetter) {
      return authoredDimensions;
    }
    const attributesFlat = node.attributes || [];
    const attributes = [];
    for (let i = 0; i < attributesFlat.length; i += 2) {
      attributes.push({ name: attributesFlat[i], value: attributesFlat[i + 1] });
    }
    const htmlHeight = attributes.find((attr) => attr.name === "height" && htmlAttributeIsExplicit(attr));
    const htmlWidth = attributes.find((attr) => attr.name === "width" && htmlAttributeIsExplicit(attr));
    const cssExplicitAspectRatio = cssMatchedRulesGetter("aspect-ratio") || void 0;
    if (htmlHeight && htmlWidth && cssExplicitAspectRatio) {
      return { height: htmlHeight.value, width: htmlWidth.value, aspectRatio: cssExplicitAspectRatio };
    }
    const cssHeight = cssMatchedRulesGetter("height") || void 0;
    const cssWidth = cssMatchedRulesGetter("width") || void 0;
    return { height: cssHeight, width: cssWidth, aspectRatio: cssExplicitAspectRatio };
  }
};
function getRenderBlockRequestsInInvalidationWindow(requestsInInvalidationWindow) {
  const renderBlockingRequests = [];
  for (let i = 0; i < requestsInInvalidationWindow.length; i++) {
    const mainFrameId2 = requestsInInvalidationWindow[i].request.args.data.frame;
    if (!networkRequestIsRenderBlockingInFrame(requestsInInvalidationWindow[i].request, mainFrameId2)) {
      continue;
    }
    renderBlockingRequests.push(requestsInInvalidationWindow[i]);
  }
  return renderBlockingRequests;
}
function firstIframeInDOMTree(root) {
  if (root.nodeName === "IFRAME") {
    return root;
  }
  const children = root.children;
  if (!children) {
    return null;
  }
  for (const child of children) {
    const iFrameInChild = firstIframeInDOMTree(child);
    if (iFrameInChild) {
      return iFrameInChild;
    }
  }
  return null;
}
function cssPropertyIsExplicitlySet(propertyValue) {
  return !["auto", "initial", "unset", "inherit"].includes(propertyValue);
}
function htmlAttributeIsExplicit(attr) {
  return parseInt(attr.value, 10) >= 0;
}
function computedStyleHasBackroundImage(computedStyle) {
  const CSS_URL_REGEX = /^url\("([^"]+)"\)$/;
  const backgroundImage = computedStyle.get("background-image");
  if (!backgroundImage) {
    return false;
  }
  return CSS_URL_REGEX.test(backgroundImage);
}
function computedStyleHasFixedPosition(computedStyle) {
  const position = computedStyle.get("position");
  if (!position) {
    return false;
  }
  return position === "fixed" || position === "absolute";
}
function getNodeComputedDimensions(computedStyle) {
  const computedDimensions = {};
  computedDimensions.height = computedStyle.get("height");
  computedDimensions.width = computedStyle.get("width");
  computedDimensions.aspectRatio = computedStyle.get("aspect-ratio");
  return computedDimensions;
}
async function nodeIsUnfixedMedia(node, computedStyle) {
  const localName = node.localName;
  const isBackgroundImage = computedStyleHasBackroundImage(computedStyle);
  if (localName !== "img" && localName !== "video" && !isBackgroundImage) {
    return false;
  }
  const isFixed = computedStyleHasFixedPosition(computedStyle);
  return !isFixed;
}
function dimensionsAreExplicit(dimensions) {
  const { height, width, aspectRatio: aspectRatio2 } = dimensions;
  const explicitHeight = Boolean(height && cssPropertyIsExplicitlySet(height));
  const explicitWidth = Boolean(width && cssPropertyIsExplicitlySet(width));
  const explicitAspectRatio = Boolean(aspectRatio2 && cssPropertyIsExplicitlySet(aspectRatio2));
  const explicitWithAR = (explicitHeight || explicitWidth) && explicitAspectRatio;
  return explicitHeight && explicitWidth || explicitWithAR;
}
function getShiftsByPrePaintEvents(layoutShifts, prePaintEvents2) {
  const shiftsByPrePaint = /* @__PURE__ */ new Map();
  for (const prePaintEvent of prePaintEvents2) {
    const firstShiftIndex = array_utilities_exports.nearestIndexFromBeginning(layoutShifts, (shift) => shift.ts >= prePaintEvent.ts);
    if (firstShiftIndex === null) {
      continue;
    }
    for (let i = firstShiftIndex; i < layoutShifts.length; i++) {
      const shift = layoutShifts[i];
      if (shift.ts >= prePaintEvent.ts && shift.ts <= prePaintEvent.ts + prePaintEvent.dur) {
        const shiftsInPrePaint = map_utilities_exports.getWithDefault(shiftsByPrePaint, prePaintEvent, () => []);
        shiftsInPrePaint.push(shift);
      }
      if (shift.ts > prePaintEvent.ts + prePaintEvent.dur) {
        break;
      }
    }
  }
  return shiftsByPrePaint;
}

// front_end/models/trace/root-causes/RootCauses.ts
var RootCauses = class {
  layoutShifts;
  constructor(protocolInterface) {
    this.layoutShifts = new LayoutShiftRootCauses(protocolInterface);
  }
};

// front_end/models/trace/trace.ts
import * as TracingManager from "./TracingManager.js";
export {
  EntriesFilter_exports as EntriesFilter,
  Extras,
  handlers_exports as Handlers,
  helpers_exports as Helpers,
  LegacyTracingModel_exports as Legacy,
  Processor_exports as Processor,
  root_causes_exports as RootCauses,
  ModelImpl_exports as TraceModel,
  TracingManager,
  types_exports as Types
};
//# sourceMappingURL=trace.mjs.map
